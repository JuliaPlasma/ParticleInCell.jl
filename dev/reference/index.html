<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference Manual · ParticleInCell2.jl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ParticleInCell2.jl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Example Gallery</a></li><li><a class="tocitem" href="../theory/">Plasma Simulation Theory</a></li><li class="is-active"><a class="tocitem" href>Reference Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adamslc/ParticleInCell2.jl/blob/main/docs/src/reference/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-Manual"><a class="docs-heading-anchor" href="#Reference-Manual">Reference Manual</a><a id="Reference-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-Manual" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.ParticleInCell2" href="#ParticleInCell2.ParticleInCell2"><code>ParticleInCell2.ParticleInCell2</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>ParticleInCell2.jl</code> is a Julia package for kinetic plasma physics simulation. Specifically, it focuses on the simulation of kinetic (non-thermal) plasmas using particle-in-cell (PIC) algorithms. Currently, this package is in in a pre-1.0.0 state, and thus breaking changes should be expected. However, this also means that I am willing to entertain radical suggestions to improve the functionality of the package. If you are interested in using <code>ParticleInCell2</code> for your plasma research, and you find that it does not meet you needs, please reach out on either GitHub, or over email, so that we can discuss how the package can be modified to suite your needs.</p><p><strong>Getting Started</strong></p><p><code>ParticleInCell2</code> is currently not registered in the Julia package registry. Thus, to install this package, you should use <code>Pkg.develop</code>:</p><pre><code class="language-julia hljs">using Pkg
Pkg.develop(url=&quot;https://github.com/adamslc/ParticleInCell2.jl&quot;)</code></pre><p><strong>Documentation</strong></p><p>You can view the latest documentation <a href="https://adamslc.github.io/ParticleInCell2.jl/dev">here</a>.</p><p><strong>Goals</strong></p><ul><li>Fast: aim to have core time of less than 1 microsecond per particle per step without collisions.</li><li>Flexible: it should be possible to implement essentially any kinetic plasma simulation in <code>ParticleInCell2.jl</code>. For common types of simulations, this might mean just piecing together components that are already included. More esoteric problems might require writing custom types that implement the desired algorithms. The advantage of writing this package in Julia is that these custom types will be just as performant as native components that are included in the package.</li><li>Scalable: the eventual goal is to enable scaling across an essentially unlimited number of cores using Julia&#39;s native multithreading for parallelization on a single node, and <code>MPI.jl</code> for communication across nodes. The goal is to support two different modes of parallelization:<ul><li>Each core is responsible for a single rectangular subdomain. The domain assigned to an entire node is also rectangular, which imposes constraints on how the node domain can be subdivided into subdomains for each core. Load balancing is achieved by varying the relative sizes of the domains such that each core has a similar amount of work per step.</li><li>The simulation domain is subdivided into subdomains called &#39;patches&#39;, and every node is assigned a list of patches that it is responsible for updating. The cores on each node work collaboratively on the list, each choosing one patch to work on, and then selecting another when they are finished. Load balancing is achieved by swapping patches between nodes to balance the workload while also seeking to minimize communication time by keeping the surface area of each node&#39;s responsibilities minimized. In order for this scheme to effectively load balance, it must be the case that the total number of patches is larger (ideally much larger) that the total number of cores.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/ParticleInCell2.jl#L4-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.AbstractGrid" href="#ParticleInCell2.AbstractGrid"><code>ParticleInCell2.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parent type for all grid objects, which are used to define the simulation domain, and to convert between coordinate systems. There are three different numbering systems that can refer to a location in the simulation domain:</p><ol><li>The &#39;physical coordinates&#39; of a point are the real (dimensionalful) coordinates associated with that point. This value can range from the lower bounds to the upper bounds of the simulation. This value will typically take the form <code>Vector{T}</code> or <code>NTuple{N, T}</code> where <code>T &lt;: Real</code>.</li><li>The &#39;cell coordinates&#39; of a point is the non-dimensional location of the point in units of cell lengths. This value can range from 0 to num_cells - 1, or outside this range if guard cells are included. The value will typically have the type <code>NTuple{N, Int}</code>.</li><li>The &#39;cell index&#39; of a point is the <code>CartesianIndex</code> that can be used to index into field arrays at that point. This value must strictly be confined to <code>axes(field.values)</code>, which, for any given dimension, will typically range from 1 to num<em>cells + 2*num</em>guard_cells + 1.</li></ol><p>The first two types of indexing, phys<em>coords and cell</em>coords, are independent of the number of guard cells in a given field, and depend only on grid quantities. Thus utilities for converting between these systems require only a reference to a grid object. On the other hand, the utilities for cell_index are specific the field being used, and thus those must be provided an <code>AbstractField</code> to do the coordinate conversion.</p><p>In general, physical coordinates are useful when considering the location of a particle, while the cell index is used to interpolate to and from the particle locations. The cell coordinates are useful for some interpolation algorithms, especially those that are defined for non-uniform grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/grid.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.UniformCartesianGrid" href="#ParticleInCell2.UniformCartesianGrid"><code>ParticleInCell2.UniformCartesianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformCartesianGrid(lower_bounds, upper_bounds, num_cells, periodic)</code></pre><p>The simplest grid type, which represents a set of equally spaced rectangular cells. The grid can optionally be periodic in one or more dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/uniform_cartesian_grid.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.cell_coords_to_phys_coords" href="#ParticleInCell2.cell_coords_to_phys_coords"><code>ParticleInCell2.cell_coords_to_phys_coords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cell_coords_to_phys_coords(grid, idxs, [offset, component])</code></pre><p>Converts the cell coordinates <code>idxs</code> to a physical coordinate using the geometry specified in <code>grid</code>. Optionally, an offset and component can be specified to get the physical coordinates of a specific <code>edge</code> or <code>face</code> of the cell. The component argument is one-indexed.</p><p>For more information on the different types of coordinate systems, see <code>AbstractGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/grid.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.cell_lengths" href="#ParticleInCell2.cell_lengths"><code>ParticleInCell2.cell_lengths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cell_lengths(grid, [cell_coords])</code></pre><p>Returns the length of the cell located at <code>cell_coords</code>. For uniform grids, the <code>cell_coords</code> argument is optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/grid.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.compute_bspline_coeffs" href="#ParticleInCell2.compute_bspline_coeffs"><code>ParticleInCell2.compute_bspline_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_bspline_coeffs(degree, [T])</code></pre><p>Returns a vector of vectors of the coefficients for the b-spline with polynomial <code>degree</code>, and unit-spaced knots, centered at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/interpolation.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.compute_knots-Tuple{Any}" href="#ParticleInCell2.compute_knots-Tuple{Any}"><code>ParticleInCell2.compute_knots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_knots(degree)</code></pre><p>Returns a vector of the knot locations for a polynomial b-spline with <code>degree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/interpolation.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.phys_coords_to_cell_coords" href="#ParticleInCell2.phys_coords_to_cell_coords"><code>ParticleInCell2.phys_coords_to_cell_coords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phys_coords_to_cell_coords(grid, xs)</code></pre><p>Converts the physical coordinate <code>xs</code> to a grid coordinate using the geometry specified in <code>grid</code>.</p><p>For more information on the different types of coordinate systems, see <code>AbstractGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/grid.jl#L66-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParticleInCell2.sim_lengths" href="#ParticleInCell2.sim_lengths"><code>ParticleInCell2.sim_lengths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_lengths(grid)</code></pre><p>Returns a tuple of the length of the simulation domain in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adamslc/ParticleInCell2.jl/blob/f43370f0ac1d623c1a2d039cd9a1e8ea8ceda005/src/grids/grid.jl#L32-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Plasma Simulation Theory</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 2 August 2023 19:36">Wednesday 2 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
