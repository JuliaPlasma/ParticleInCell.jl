<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ParticleInCell.jl Documentation</title><meta name="title" content="Tutorial · ParticleInCell.jl Documentation"/><meta property="og:title" content="Tutorial · ParticleInCell.jl Documentation"/><meta property="twitter:title" content="Tutorial · ParticleInCell.jl Documentation"/><meta name="description" content="Documentation for ParticleInCell.jl Documentation."/><meta property="og:description" content="Documentation for ParticleInCell.jl Documentation."/><meta property="twitter:description" content="Documentation for ParticleInCell.jl Documentation."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">ParticleInCell.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Simulating-a-cold-electron-plasma"><span>Simulating a cold electron plasma</span></a></li><li><a class="tocitem" href="#Scaling-of-frequency-error-with-wavenumber"><span>Scaling of frequency error with wavenumber</span></a></li><li><a class="tocitem" href="#Wrap-up"><span>Wrap up</span></a></li></ul></li><li><a class="tocitem" href="../../">Example Gallery</a></li><li><span class="tocitem">Plasma simulation theory</span><ul><li><a class="tocitem" href="../../../theory/">Introduction</a></li><li><a class="tocitem" href="../../../theory/intro_to_pic/">PIC simulation</a></li></ul></li><li><a class="tocitem" href="../../../manual/">Manual</a></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPlasma/ParticleInCell.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPlasma/ParticleInCell.jl/blob/main/examples/tutorial/langmuir_oscillation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_langmuir"><a class="docs-heading-anchor" href="#tutorial_langmuir">Tutorial: Langmuir oscillations</a><a id="tutorial_langmuir-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_langmuir" title="Permalink"></a></h1><p><a href="../langmuir_oscillation.jl"><img src="https://img.shields.io/badge/download-julia-brightgreen.svg" alt="Source code"/></a> <a href="https://nbviewer.jupyter.org/github/JuliaPlasma/ParticleInCell.jl/blob/gh-pages/dev/examples/tutorial/langmuir_oscillation.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt="notebook"/></a></p><p>In this tutorial, you will use <code>ParticleInCell</code> to model one of the simplest phenomena in plasma physics: an electrostatic (or Langmuir) oscillation. This tutorial is part of a series of examples that uses <code>ParticleInCell</code> to demonstrate the basic plasma physics concepts that are covered in <a href="../../../references/#birdsall2004">Birdsall and Langdon&#39;s classic PIC textbook</a>.</p><p>A Langmuir oscillation occurs when a slab of charge in a uniform plasma is displaced. The resulting charge density gradient creates a restoring force that causes the displaced slab of charge to return to its original position. But–-just as in a classical pendulum oscillation–-the momentum of the charge carries it past its equilibrium point, creating an opposite charge gradient, and a restoring force in the opposite direction. As a result, the slab of charge oscillates around its equilibrium forever (at least in this idealized model that ignores possible damping mechanisms). For a plasma composed of a single mobile species <span>$s$</span> with mass <span>$m_s$</span> and charge <span>$q_s$</span>, the frequency of this oscillation is given by</p><p class="math-container">\[\omega_{p,s} = \sqrt{\frac{n_s q_s^2}{\epsilon_0 m_s}}\]</p><p>where <span>$n_s$</span> is the number density of the plasma and <span>$\epsilon_0$</span> is the permitivity of free space. Notice that the plasma frequency has a <span>$m_s^{-1/2}$</span> dependence, and thus the lightest species (typically electrons) will dominate the dynamics of a plasma oscillation. For this reason, we will only model the dynamics of the electrons in our simulation.</p><h2 id="Simulating-a-cold-electron-plasma"><a class="docs-heading-anchor" href="#Simulating-a-cold-electron-plasma">Simulating a cold electron plasma</a><a id="Simulating-a-cold-electron-plasma-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-a-cold-electron-plasma" title="Permalink"></a></h2><p>We begin by loading the <code>ParticleInCell</code> package. Additionally, we load <code>CairoMakie</code> which is a backend for <a href="https://makie.org"><code>Makie</code></a> that can generate beautiful, publication-quality graphics.</p><pre><code class="language-julia hljs">using ParticleInCell
using CairoMakie
docs_theme = Theme(
    fontsize = 20,
    fonts = (; regular = &quot;Lato&quot;, bold = &quot;Lato Bold&quot;),
    palette = (color = [:black, :red, :blue],),
    Axis = (xgridvisible = false, ygridvisible = false),
    Scatter = (; cycle = [:color]),
    Lines = (; cycle = [:color]),
)</code></pre><p>We begin by creating some electrons to move in the simulation. For even a tiny simulation volume, there are <em>far</em> too many physical electrons to simulate each one individually. Instead, PIC algorithms group physical particles into &#39;macroparticles&#39;. The distribution of macroparticles in phase space serves as an approximation for the phase space distribution of physical particles. We arbitrarily choose a simulation domain of length one, and a nominal electrons number density of <span>$10^{14}$</span>. Then, for a given number of macroparticles, we can calculate the number of physical electrons represented by each.</p><pre><code class="language-julia hljs">sim_length = 1.0
number_density = 1e14
num_macroparticles = 320
particles_per_macro = number_density * sim_length / num_macroparticles</code></pre><pre><code class="nohighlight hljs">3.125e11</code></pre><p>We distribute the macroparticles evenly across the simulation domain.</p><pre><code class="language-julia hljs">positions = collect(0:num_macroparticles-1) ./ num_macroparticles;</code></pre><p>In order to seed a Langmuir oscillation, we give the electrons a sinusoidal velocity perturbation. This corresponds to the moment in a Langmuir oscillation when the slab of charge has reached equilibrium, but is being carried past by its momentum. This perturbation is defined by a wavenumber <code>k</code> and an <code>amplitude</code>.</p><pre><code class="language-julia hljs">k = 1 * 2pi / sim_length
amplitude = 1e3
elec_mass = 9e-31
momentums = (particles_per_macro * elec_mass * amplitude) .* sin.(positions .* k);</code></pre><p>We can visualize the initial condition of the electron macroparticle by plotting the initial phase space.</p><pre><code class="language-julia hljs">fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Electron phase space&quot;,
    xlabel = &quot;Position (m)&quot;,
    ylabel = &quot;Momentum (arb. units)&quot;,
    limits = ((0, 1), nothing),
)
scatter!(ax, positions, momentums ./ maximum(momentums))
fig</code></pre><p><img src="../langmuir_oscillation-12.svg" alt/></p><p>Finally, we create a <code>VariableWeightSpecies</code> which holds the all of the macroparticles. Additionally, we must pass the value of <code>particles_per_macro</code>, which is used to calculate the charge and mass of the macroparticles.</p><pre><code class="language-julia hljs">electrons = ParticleInCell.electrons(positions, momentums, particles_per_macro);</code></pre><p>Now we address the &#39;cell&#39; piece of particle-in-cell by creating a <code>grid</code>. Because Langmuir oscillations are a one-dimensional phenomena, we will choose to perform a 1D simulation.</p><p>The choice of grid resolution is determined by the scale of the smallest relevant dynamics begin simulated. For a Langmuir oscillation, the scale of the dynamics is set by <code>k</code>, and so the simulation could likely accomplished with as few as 4 or 8 cells. However, this is not a computationally demanding simulation, and so we arbitrarily choose to use 32 equally spaced (i.e. uniform) grid points. Additionally, we make the simulation domain periodic.</p><pre><code class="language-julia hljs">num_cells = 32
dx = sim_length / num_cells
periodic = true
grid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (periodic,));</code></pre><p>At this point, we must choose a timestep for the simulation. We would like to use a large timestep so that more of the systems dynamics can be observed with the same number of steps. However, we must resolve the fastest timescale of the dynamics that we are trying to simulate. In this case, we must resolve the plasma frequency. Additionally, we must choose a timestep that is short enough that particles do not cross more than one cell per timestep to prevent numerical instabilities from arising. For the oscillation amplitude that we have chosen, the particles do not move fast enough for the CFL condition to matter, and so we will choose our timestep based on the expected plasma frequency.</p><pre><code class="language-julia hljs">epsilon_0 = 8.8e-12
elec_charge = 1.6e-19
elec_mass = 9e-31
expected_plasma_freq = sqrt(number_density * elec_charge^2 / elec_mass / epsilon_0)
expected_plasma_period = 2pi / expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">1.1051531770007306e-8</code></pre><p>In order for the simulation to be accurate, there must be several timesteps per plasma period (or equivalently, several timesteps per inverse plasma frequency). For now, we will arbitrarily choose to have 100 timesteps per plasma period, and later, we will explore how changing the time step effects the accuracy of the simulation.</p><pre><code class="language-julia hljs">dt = 0.01 / expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">1.7589059099337862e-11</code></pre><p>Now we need to set up the fields required for the electrostatic PIC simulation, as well as specify the exact steps that will occur during each step.. To do this, we will use a helper function to create the fields and steps.</p><pre><code class="language-julia hljs">sim, fields = create_electrostatic_simulation(grid, [electrons], dt);</code></pre><p>The variable <code>sim</code> holds the steps, and <code>fields</code> is a named tuple of the rho, phi, and electric fields (actually two electric fields, one at the edge of each grid cell, and one at the nodes). In this tutorial, we won&#39;t go over the details of the PIC method, but you can find more details in the theory section of the manual. However, we will need the nodal electric field later in the tutorial, so we assign that field to its own variable.</p><pre><code class="language-julia hljs">Enode = fields[:Enode];</code></pre><p>Now we are ready to run the simulation. We will simulate the plasma for 1000 timesteps, and at each step, we will calculate the electric field energy,</p><p class="math-container">\[U_E = \int |E(x)|^2 \,\mathrm{d}x.\]</p><p>This field energy will oscillate as the electrons move in and out of equilibrium, and so we can use it to observe the Langmuir oscillation.</p><pre><code class="language-julia hljs">n_steps = 10000

electric_field_energy = Vector{Float64}(undef, n_steps)

for n = 1:n_steps
    # Calculate the electric field energy
    electric_field_energy[n] = 0
    for I in eachindex(Enode)
        electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2
    end

    step!(sim)
end</code></pre><p>We can now visualize the electric field energy to see the plasma oscillation.</p><pre><code class="language-julia hljs">normalized_times = collect(range(1, n_steps)) .* dt .* expected_plasma_freq
fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Electric Field Energy&quot;,
    xlabel = &quot;Normalized Time&quot;,
    ylabel = &quot;Energy&quot;,
    limits = ((0, 100), nothing),
)
lines!(normalized_times, electric_field_energy)
fig</code></pre><p><img src="../langmuir_oscillation-28.svg" alt/></p><p>Notice that the electric field energy is slowly growing over time, which is unphysical. We will discuss where this numerical instability comes from– and how it can be avoided–later. But for now, we can still use the electric-field-energy time series to calculate the plasma frequency. First, let&#39;s plot the Fourier transform of the electric field energy.</p><pre><code class="language-julia hljs">using FFTW

freqs = fftfreq(n_steps, 1 / dt) .* 2pi
freq_amps = abs.(fft(electric_field_energy))

fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Electric Field Energy Spectrum&quot;,
    xlabel = &quot;Frequency&quot;,
    ylabel = &quot;Amplitude&quot;,
)
lines!(ax, freqs, freq_amps)
fig</code></pre><p><img src="../langmuir_oscillation-30.svg" alt/></p><p>It is hard to see what is happening at the low frequencies, so let&#39;s zoom in on the positive low frequencies.</p><pre><code class="language-julia hljs">cutoff_index = round(Int, n_steps * 0.005)
fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Electric Field Energy Spectrum&quot;,
    xlabel = &quot;Frequency&quot;,
    ylabel = &quot;Amplitude&quot;,
)
lines!(ax, freqs[1:cutoff_index], freq_amps[1:cutoff_index])
fig</code></pre><p><img src="../langmuir_oscillation-32.svg" alt/></p><p>Next, we find the maximum frequency. We don&#39;t care about the spike at zero frequency (that is just a consequence of the electric field energy being a strictly positive quantity) so we will zero out all of the frequencies below <span>$5 \times 10^8$</span> Hz. We then find the largest remaining amplitude, and it&#39;s corresponding frequency.</p><pre><code class="language-julia hljs">freq_amps .= ifelse.(freqs .&lt; 5e8, 0, freq_amps)
max_index = findmax(freq_amps)[2]
max_freq = freqs[max_index]

# Divide by 2 because the electric field energy goes through a maximum twice
# per plasma oscillation, and take the absolute value because we don&#39;t care
# about the phase of the oscillation.
measured_plasma_freq = abs(max_freq / 2)</code></pre><pre><code class="nohighlight hljs">5.5369290484077e8</code></pre><p>One last plot, showing the zeroed out low frequencies, and the measured oscillation frequency:</p><pre><code class="language-julia hljs">fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Electric Field Energy Spectrum&quot;,
    xlabel = &quot;Frequency&quot;,
    ylabel = &quot;Amplitude&quot;,
)
lines!(ax, freqs[1:cutoff_index], freq_amps[1:cutoff_index])
vlines!(ax, [measured_plasma_freq * 2])
fig</code></pre><p><img src="../langmuir_oscillation-36.svg" alt/></p><p>Finally, we can compare this to the theoretically expected result:</p><pre><code class="language-julia hljs">relative_error = (measured_plasma_freq - expected_plasma_freq) / expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">-0.026106277387164183</code></pre><p>Less than a 5% error.</p><h2 id="Scaling-of-frequency-error-with-wavenumber"><a class="docs-heading-anchor" href="#Scaling-of-frequency-error-with-wavenumber">Scaling of frequency error with wavenumber</a><a id="Scaling-of-frequency-error-with-wavenumber-1"></a><a class="docs-heading-anchor-permalink" href="#Scaling-of-frequency-error-with-wavenumber" title="Permalink"></a></h2><p>In the previous section, we seeded a plasma oscillation that spanned the entire simulation domain. That is, the wavenumber was</p><p class="math-container">\[k_\text{min} = \frac{2 \pi}{\lambda} = \frac{2 \pi}{L}.\]</p><p>This is the best possible case, because the oscillation spans as many grid cells as possible. However, as the wavenumber increases (and equivalently, the wavelength decreases), the finite grid effects will start to become more important, and they will result in an increased error in the measured plasma frequency.</p><p>Our goal in this section will be to observe and quantify this finite grid error. We begin by defining a function that will run a PIC simulation at a specified wavenumber, and return the measured plasma frequency.</p><pre><code class="language-julia hljs">function measure_plasma_frequency(number_density, wavenumber, normalized_timestep = 0.01)
    sim_length = 1.0
    num_cells = 32
    dx = sim_length / num_cells

    num_macroparticles = 10 * num_cells
    particles_per_macro = number_density * sim_length / num_macroparticles

    perturb_amplitude = 1e3
    elec_mass = 9e-31
    positions = collect(0:num_macroparticles-1) ./ num_macroparticles
    momentums =
        (particles_per_macro * elec_mass * perturb_amplitude) .*
        sin.(positions .* wavenumber)

    electrons = ParticleInCell.electrons(positions, momentums, particles_per_macro)

    grid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (true,))

    epsilon_0 = 8.8e-12
    elec_charge = 1.6e-19
    expected_plasma_freq = sqrt(number_density * elec_charge^2 / elec_mass / epsilon_0)
    dt = normalized_timestep / expected_plasma_freq
    sim, fields = create_electrostatic_simulation(grid, [electrons], dt)
    Enode = fields[:Enode]

    # We want to simulate the same length of physical time for each simulation,
    # so we need to have more steps when the timestep is shorter.
    n_steps = round(Int, 100 / normalized_timestep)
    electric_field_energy = Vector{Float64}(undef, n_steps)

    epsilon_0 = 8.8e-12
    for n = 1:n_steps
        # Calculate the electric field energy
        electric_field_energy[n] = 0
        for I in eachindex(Enode)
            electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2
        end

        step!(sim)
    end

    freqs = fftfreq(n_steps, 1 / dt) .* 2pi
    freq_amps = abs.(fft(electric_field_energy))

    freq_amps[1] = 0
    max_index = findmax(freq_amps)[2]
    max_freq = freqs[max_index]
    plasma_freq = abs(max_freq / 2)

    return plasma_freq
end;</code></pre><p>Let&#39;s run several simulations with different timesteps, and compare the accuracy of each simulation.</p><pre><code class="language-julia hljs">wavenumbers = 2 * pi .* [2, 4, 8, 16]
plasma_freqs = measure_plasma_frequency.(1e14, wavenumbers, 0.001)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Float64}:
 5.536929048407701e8
 5.179707819478172e8
 3.9294335182248205e8
 1.7861061446476456e7</code></pre><p>Let&#39;s plot the wavenumber of the oscillation verses the relative error between the observed and predicted plasma frequencies. We expect that the error will be some power law relation to the wavenumber, and so we will use a log-log plot.</p><pre><code class="language-julia hljs">dx = 1 / 32
normalized_wavenumbers = wavenumbers .* dx
relative_errors = abs.(plasma_freqs ./ expected_plasma_freq .- 1)

fig = Figure(size = (1000, 400))
ax = Axis(
    fig[1, 1],
    title = &quot;Frequency error&quot;,
    xlabel = L&quot;k \Delta x&quot;,
    ylabel = L&quot;\left|\frac{\omega}{\omega_p} - 1\right|&quot;,
    xscale = log10,
    yscale = log10,
)
scatter!(ax, normalized_wavenumbers, relative_errors)
fig</code></pre><p><img src="../langmuir_oscillation-44.svg" alt/></p><p>Indeed, the error does appear to have a power law relation with the normalized wavenumber. Let&#39;s fit the data to determine the index of the power law. We will use the <code>LsqFit</code> package, which provides utilities for fitting data. We have observed that the data is linear when plotted on a log-log plot, and so we will fit the log-transformed data using a linear model.</p><pre><code class="language-julia hljs">using LsqFit

model(x, p) = p[1] .+ x .* p[2]
fit = curve_fit(model, log10.(normalized_wavenumbers), log10.(relative_errors), [0.0, 2.0])
params = coef(fit)</code></pre><pre><code class="nohighlight hljs">2-element Vector{Float64}:
 -0.8690885032869285
  1.743625642496926</code></pre><p>Notice that the second parameter, which corresponds to the exponent in the power law, is about two. This makes sense, because the PIC algorithm we are using has second order accuracy in <span>$k \Delta x$</span>. As a final sanity check, let&#39;s plot the fit.</p><pre><code class="language-julia hljs">lines!(
    ax,
    normalized_wavenumbers,
    (10^params[1]) .* normalized_wavenumbers .^ params[2],
    color = :red,
)
fig</code></pre><p><img src="../langmuir_oscillation-48.svg" alt/></p><p>There is one last thing we can do with this error model: we can us it to correct out simulation results! Our model gives us the relation</p><p class="math-container">\[\left|\frac{\omega}{\omega_p} - 1\right| = C (k \Delta x)^p.\]</p><p>We can solve for <span>$\omega_p$</span>, to obtain</p><p class="math-container">\[\omega_p = \frac{\omega}{1 \pm C (k \Delta x)^p}.\]</p><p>Let&#39;s find the error in the corrected plasma frequencies.</p><pre><code class="language-julia hljs">corrected_plasma_freqs =
    plasma_freqs ./ (1 .- (10^params[1]) .* normalized_wavenumbers .^ params[2])
corrected_relative_errors =
    (corrected_plasma_freqs .- expected_plasma_freq) ./ expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">4-element Vector{Float64}:
  0.0003955396156326958
 -0.00024698896102469636
 -0.01674606541861653
  5.092479974228979</code></pre><p>Of course, this example is somewhat unrealistic: if we already know what the plasma frequency should be, why are we running simulations to measure it?!?! However, this general technique remains valid, even when we don&#39;t know what the correct answer is a priori. This is why it is so important to conduct scaling studies to gain confidence that your simulation is actually resolving the physics that you think it is.</p><h2 id="Wrap-up"><a class="docs-heading-anchor" href="#Wrap-up">Wrap up</a><a id="Wrap-up-1"></a><a class="docs-heading-anchor-permalink" href="#Wrap-up" title="Permalink"></a></h2><p>In this tutorial, you have learned how to simulate an electrostatic Langmuir oscillation using <code>ParticleInCell</code>. Additionally, you have verified error scaling of the algorithm in <span>$k \Delta x$</span>, and used this information to correct the originally measured plasma frequency.</p><hr/><p><em>This page was generated using <a href="https://github.com/JuliaDocs/DemoCards.jl">DemoCards.jl</a> and <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Introduction</a><a class="docs-footer-nextpage" href="../../">Example Gallery »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaPlasma/ParticleInCell.jl">ParticleInCell.jl</a> v1.0.0</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 23 October 2024 21:32">Wednesday 23 October 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
