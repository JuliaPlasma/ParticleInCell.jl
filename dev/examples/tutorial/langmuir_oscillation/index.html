<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ParticleInCell2.jl Documentation</title><meta name="title" content="Tutorial · ParticleInCell2.jl Documentation"/><meta property="og:title" content="Tutorial · ParticleInCell2.jl Documentation"/><meta property="twitter:title" content="Tutorial · ParticleInCell2.jl Documentation"/><meta name="description" content="Documentation for ParticleInCell2.jl Documentation."/><meta property="og:description" content="Documentation for ParticleInCell2.jl Documentation."/><meta property="twitter:description" content="Documentation for ParticleInCell2.jl Documentation."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">ParticleInCell2.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Simulating-a-cold-electron-plasma"><span>Simulating a cold electron plasma</span></a></li><li><a class="tocitem" href="#Adding-temperature-to-the-plasma"><span>Adding temperature to the plasma</span></a></li></ul></li><li><a class="tocitem" href="../../">Example Gallery</a></li><li><span class="tocitem">Plasma simulation theory</span><ul><li><a class="tocitem" href="../../../theory/">Introduction</a></li><li><a class="tocitem" href="../../../theory/intro_to_pic/">PIC simulation</a></li></ul></li><li><a class="tocitem" href="../../../manual/">Manual</a></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adamslc/ParticleInCell2.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adamslc/ParticleInCell2.jl/blob/main/examples/tutorial/langmuir_oscillation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_langmuir"><a class="docs-heading-anchor" href="#tutorial_langmuir">Tutorial: Langmuir oscillations</a><a id="tutorial_langmuir-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_langmuir" title="Permalink"></a></h1><p><a href="../langmuir_oscillation.jl"><img src="https://img.shields.io/badge/download-julia-brightgreen.svg" alt="Source code"/></a> <a href="https://nbviewer.jupyter.org/github/adamslc/ParticleInCell2.jl/blob/gh-pages/dev/examples/tutorial/langmuir_oscillation.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt="notebook"/></a></p><p>In this tutorial, you will use <code>ParticleInCell2</code> to model one of the simplest phenomena in plasma physics: an electrostatic (or Langmuir) oscillation. This tutorial is part of a series of examples that uses <code>ParticleInCell2</code> to demonstrate the basic plasma physics concepts that are covered in <a href="../../../references/#birdsall2004">Birdsall and Langdon&#39;s classic PIC textbook</a>.</p><p>A Langmuir oscillation occurs when a slab of charge in a uniform plasma is displaced. The resulting charge density gradient creates a restoring force that causes the displaced slab of charge to return to its original position. But–-just as in a classical pendulum oscillation–-the momentum of the charge carries it past its equilibrium point, creating an opposite charge gradient, and a restoring force in the opposite direction. As a result, the slab of charge oscillates around its equilibrium forever (at least in this idealized model that ignores possible damping mechanisms). For a plasma composed of a single mobile species <span>$s$</span> with mass <span>$m_s$</span> and charge <span>$q_s$</span>, the frequency of this oscillation is given by</p><p class="math-container">\[\omega_{p,s} = \sqrt{\frac{n_s q_s^2}{\epsilon_0 m_s}}\]</p><p>where <span>$n_s$</span> is the number density of the plasma and <span>$\epsilon_0$</span> is the permitivity of free space. Notice that the plasma frequency has a <span>$m_s^{-1/2}$</span> dependence, and thus the lightest species (typically electrons) will dominate the dynamics of a plasma oscillation. For this reason, we will only model the dynamics of the electrons in our simulation.</p><h2 id="Simulating-a-cold-electron-plasma"><a class="docs-heading-anchor" href="#Simulating-a-cold-electron-plasma">Simulating a cold electron plasma</a><a id="Simulating-a-cold-electron-plasma-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-a-cold-electron-plasma" title="Permalink"></a></h2><p>We begin by loading the <code>ParticleInCell2</code> package. Additionally, we load <code>CairoMakie</code> which is a backend for <a href="https://makie.org"><code>Makie</code></a> that can generate beautiful, publication-quality graphics.</p><pre><code class="language-julia hljs">using ParticleInCell2
using CairoMakie</code></pre><p>We begin by creating some electrons to move in the simulation. For even a tiny simulation volume, there are <em>far</em> too many physical electrons to simulate each one individually. Instead, PIC algorithms group physical particles into &#39;macroparticles&#39;. The distribution of macroparticles in phase space serves as an approximation for the phase space distribution of physical particles. We arbitrarily choose a simulation domain of length one, and a nominal electrons number density of <span>$10^{14}$</span>. Then, for a given number of macroparticles, we can calculate the number of physical electrons represented by each.</p><pre><code class="language-julia hljs">sim_length = 1.0
number_density = 1e14
num_macroparticles = 320
particles_per_macro = number_density * sim_length / num_macroparticles</code></pre><pre><code class="nohighlight hljs">3.125e11</code></pre><p>We distribute the macroparticles evenly across the simulation domain.</p><pre><code class="language-julia hljs">positions = collect(0:num_macroparticles-1) ./ num_macroparticles;</code></pre><p>In order to seed a Langmuir oscillation, we give the electrons a sinusoidal velocity perturbation. This corresponds to the moment in a Langmuir oscillation when the slab of charge has reached equilibrium, but is being carried past by its momentum. This perturbation is defined by a wavenumber <code>k</code> and an <code>amplitude</code>.</p><pre><code class="language-julia hljs">k = 1 * 2pi / sim_length
amplitude = 1e3
elec_mass = 9e-31
momentums = (particles_per_macro * elec_mass * amplitude) .* sin.(positions .* k);</code></pre><p>We can visualize the initial condition of the electron macroparticle by plotting the initial phase space.</p><pre><code class="language-julia hljs">scatter(
    positions,
    momentums;
    axis = (;
        title = &quot;Electron phase space&quot;,
        xlabel = &quot;Position (m)&quot;,
        ylabel = &quot;Momentum (kg m / s)&quot;,
    ),
)</code></pre><p><img src="../langmuir_oscillation-12.svg" alt/></p><p>Finally, we create a <code>VariableWeightSpecies</code> which holds the all of the macroparticles. Additionally, we must pass the value of <code>particles_per_macro</code>, which is used to calculate the charge and mass of the macroparticles.</p><pre><code class="language-julia hljs">electrons = ParticleInCell2.electrons(positions, momentums, particles_per_macro);</code></pre><p>Now we address the &#39;cell&#39; piece of particle-in-cell by creating a <code>grid</code>. Because Langmuir oscillations are a one-dimensional phenomena, we will choose to perform a 1D simulation.</p><p>The choice of grid resolution is determined by the scale of the smallest relevant dynamics begin simulated. For a Langmuir oscillation, the scale of the dynamics is set by <code>k</code>, and so the simulation could likely accomplished with as few as 4 or 8 cells. However, this is not a computationally demanding simulation, and so we arbitrarily choose to use 32 equally spaced (i.e. uniform) grid points. Additionally, we make the simulation domain periodic.</p><pre><code class="language-julia hljs">num_cells = 32
dx = sim_length / num_cells
periodic = true
grid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (periodic,));</code></pre><p>Next, we set up the required fields for an electrostatic PIC simulation. In a basic PIC cycle, we first compute the charge density, <code>rho</code>, on the grid points. We then compute the corresponding electric potential, <code>phi</code>. The electric field is conventionally determined in a two step process. First the potential, which is located at the nodes of the grid cells, is finite differenced to the edges of the cells, producing an edge electric field, <code>Eedge</code>. The edge electric fields are then averaged to get the electric fields located at the nodes, <code>Enode</code>.</p><p>When creating the fields, we must specify the underlying grid on which the field is based, the location of the values of the field (i.e. are the field values located at the nodes of each cell? The edge?), the dimension of the field, and the number of guard cells surrounding the field.</p><pre><code class="language-julia hljs">field_dimension = 1
lower_guard_cells = 1
rho = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)
phi = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)
Eedge = Field(grid, ParticleInCell2.edge, field_dimension, lower_guard_cells)
Enode = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells);</code></pre><p>At this point, we must choose a timestep for the simulation. We would like to use a large timestep so that more of the systems dynamics can be observed with the same number of steps. However, we must resolve the fastest timescale of the dynamics that we are trying to simulate. In this case, we must resolve the plasma frequency. Additionally, we must choose a timestep that is short enough that particles do not cross more than one cell per timestep to prevent numerical instabilities from arising. For the oscillation amplitude that we have chosen, the particles do not move fast enough for the CFL condition to matter, and so we will choose our timestep based on the expected plasma frequency.</p><pre><code class="language-julia hljs">epsilon_0 = 8.8e-12
elec_charge = 1.6e-19
elec_mass = 9e-31
expected_plasma_freq = sqrt(number_density * elec_charge^2 / elec_mass / epsilon_0)
expected_plasma_period = 2pi / expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">1.1051531770007306e-8</code></pre><p>Once again, this is not a computationally demanding simulation, and so we will choose a relatively small timestep for improve numerical accuracy. You can play with increasing the timestep, and see when the simulation results begin to deteriorate.</p><pre><code class="language-julia hljs">dt = 5e-11</code></pre><pre><code class="nohighlight hljs">5.0e-11</code></pre><p>In the final step of the setup, we create all of the simulation steps required to do the electrostatic simulation. In this tutorial, we will not discuss the details of PIC simulation, but you can find more information about the PIC simulation cycle elsewhere in this documentation.</p><pre><code class="language-julia hljs">charge_interp = BSplineChargeInterpolation(electrons, rho, 1)
comm_rho = CommunicateGuardCells(rho, true)
field_solve = PoissonSolveFFT(rho, phi)
comm_phi = CommunicateGuardCells(phi)
finite_diff = FiniteDifferenceToEdges(phi, Eedge)
comm_Eedge = CommunicateGuardCells(Eedge)
elec_ave = AverageEdgesToNodes(Eedge, Enode)
comm_Enode = CommunicateGuardCells(Enode)
push = ElectrostaticParticlePush(electrons, Enode, dt)
comm_electrons = CommunicateSpecies(electrons, grid);</code></pre><p>Now we are ready to run the simulation. We will simulate the plasma for 1000 timesteps, and at each step, we will calculate the electric field energy,</p><p class="math-container">\[U_E = \int |E(x)|^2 \,\mathrm{d}x.\]</p><p>This field energy will oscillate as the electrons move in and out of equilibrium, and so we can use it to observe the Langmuir oscillation.</p><pre><code class="language-julia hljs">n_steps = 1000

electric_field_energy = Vector{Float64}(undef, n_steps)

for n = 1:n_steps
    # Calculate the electric field energy
    electric_field_energy[n] = 0
    for I in eachindex(Enode)
        electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2
    end

    # TODO
    rho.values .= 0

    step!(charge_interp)
    step!(comm_rho)
    step!(field_solve)
    step!(comm_phi)
    step!(finite_diff)
    step!(comm_Eedge)
    step!(elec_ave)
    step!(comm_Enode)
    step!(push)
    step!(comm_electrons)
end</code></pre><p>We can now visualize the electric field energy to see the plasma oscillation.</p><pre><code class="language-julia hljs">times = collect(range(1, n_steps)) .* dt
lines(
    times,
    electric_field_energy;
    axis = (; title = &quot;Electric Field Energy&quot;, xlabel = &quot;Time (s)&quot;, ylabel = &quot;Energy&quot;),
)</code></pre><p><img src="../langmuir_oscillation-28.svg" alt/></p><p>Notice that the electric field energy is slowly growing over time, which is unphysical. We will discuss where this numerical instability comes from– and how it can be avoided–later. But for now, we can still use the electric-field-energy time series to calculate the plasma frequency. First, let&#39;s plot the Fourier transform of the electric field energy.</p><pre><code class="language-julia hljs">using FFTW

freqs = fftfreq(n_steps, 1 / dt) .* 2pi
freq_amps = abs.(fft(electric_field_energy))

lines(
    freqs,
    freq_amps;
    axis = (;
        title = &quot;Electric Field Energy Frequency Spectrum&quot;,
        xlabel = &quot;Frequency (1/s)&quot;,
        ylabel = &quot;Amplitude&quot;,
    ),
)</code></pre><p><img src="../langmuir_oscillation-30.svg" alt/></p><p>It is hard to see what is happening at the low frequencies, so let&#39;s zoom in on the positive low frequencies.</p><pre><code class="language-julia hljs">cutoff_index = round(Int, n_steps * 0.05)
lines(
    freqs[1:cutoff_index],
    freq_amps[1:cutoff_index];
    axis = (;
        title = &quot;Electric Field Energy Frequency Spectrum&quot;,
        xlabel = &quot;Frequency (1/s)&quot;,
        ylabel = &quot;Amplitude&quot;,
    ),
)</code></pre><p><img src="../langmuir_oscillation-32.svg" alt/></p><p>Next, we find the maximum frequency. We don&#39;t care about the spike at zero frequency (that is just a consequence of the electric field energy being a strictly positive quantity) so we first set its amplitude to zero, and then find the largest remaining amplitude, and it&#39;s corresponding frequency.</p><pre><code class="language-julia hljs">freq_amps[1] = 0
max_index = findmax(freq_amps)[2]
max_freq = freqs[max_index]

# Divide by 2 because the electric field energy goes through a maximum twice
# per plasma oscillation, and take the absolute value because we don&#39;t care
# about the phase of the oscillation.
plasma_freq = abs(max_freq / 2)</code></pre><pre><code class="nohighlight hljs">5.654866776461627e8</code></pre><p>Finally, we can compare this to the theoretically expected result:</p><pre><code class="language-julia hljs">relative_error = (plasma_freq - expected_plasma_freq) / expected_plasma_freq</code></pre><pre><code class="nohighlight hljs">-0.005362140699342522</code></pre><p>Less than 1% error. Not bad!</p><h2 id="Adding-temperature-to-the-plasma"><a class="docs-heading-anchor" href="#Adding-temperature-to-the-plasma">Adding temperature to the plasma</a><a id="Adding-temperature-to-the-plasma-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-temperature-to-the-plasma" title="Permalink"></a></h2><p>In the previous simulation, the electric field energy grew unphysically throughout the simulation. This was a result of the &quot;grid-heating instability&quot;, which occurs when the grid does not resolve the plasma Debye length, which for an electron plasma is given by</p><p class="math-container">\[\lambda_{D,e} = \sqrt{\frac{\epsilon_0 k_B T}{n_e q_e^2}},\]</p><p>where <span>$k_B$</span> is the Boltzmann constant and <span>$T_e$</span> is the electron temperature.</p><p>When the Debye length of a plasma is underresolved, the plasma will unphysically heat, causing the Debye length to grow until it is resolved by the grid. Many strategies have been developed to mitigate this instability, but in this tutorial, we will simply give our plasma sufficient thermal energy to begin so that the simulation will be stable against the grid-heating instability.</p><p>Let&#39;s calculate the required electron temperature in the previous simulation so that the 32 cell grid will resolve the Debye length. We set <span>$\lambda_{D,e} = \Delta x$</span>, and solve for <span>$T$</span> to find</p><pre><code class="language-julia hljs">boltzmann_constant = 1.381e-23
dx^2 * number_density * elec_charge^2 / epsilon_0 / boltzmann_constant</code></pre><pre><code class="nohighlight hljs">2.0571390955170825e7</code></pre><p>Alternatively, we can express this temperature in terms of electron volts as</p><pre><code class="language-julia hljs">dx^2 * number_density * elec_charge / epsilon_0</code></pre><pre><code class="nohighlight hljs">1775.5681818181818</code></pre><p>We will define a function that takes an electron density, electron temperature, and oscillation wavenumber, and returns a measured plasma frequency.</p><pre><code class="language-julia hljs">function measure_plasma_frequency(number_density, temperature, wavenumber)
    sim_length = 1.0

    num_cells = 32
    dx = sim_length / num_cells

    num_macroparticles = 320
    particles_per_macro = number_density * sim_length / num_macroparticles

    perturb_amplitude = 1e3
    elec_mass = 9e-31
    boltzmann_constant = 1.381e-23
    thermal_velocity = sqrt(3 * boltzmann_constant * temperature / elec_mass)

    positions = collect(0:num_macroparticles-1) ./ num_macroparticles
    momentums =
        (particles_per_macro * elec_mass) .*
        (perturb_amplitude .* sin.(positions .* wavenumber) .+ thermal_velocity .* randn.())

    electrons = ParticleInCell2.electrons(positions, momentums, particles_per_macro)

    grid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (true,))

    field_dimension = 1
    lower_guard_cells = 1
    rho = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)
    phi = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)
    Eedge = Field(grid, ParticleInCell2.edge, field_dimension, lower_guard_cells)
    Enode = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)

    dt = 5e-11
    charge_interp = BSplineChargeInterpolation(electrons, rho, 1)
    comm_rho = CommunicateGuardCells(rho, true)
    field_solve = PoissonSolveFFT(rho, phi)
    comm_phi = CommunicateGuardCells(phi)
    finite_diff = FiniteDifferenceToEdges(phi, Eedge)
    comm_Eedge = CommunicateGuardCells(Eedge)
    elec_ave = AverageEdgesToNodes(Eedge, Enode)
    comm_Enode = CommunicateGuardCells(Enode)
    push = ElectrostaticParticlePush(electrons, Enode, dt)
    comm_electrons = CommunicateSpecies(electrons, grid)

    n_steps = 1000
    electric_field_energy = Vector{Float64}(undef, n_steps)

    epsilon_0 = 8.8e-12
    for n = 1:n_steps
        # Calculate the electric field energy
        electric_field_energy[n] = 0
        for I in eachindex(Enode)
            electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2
        end

        # TODO
        rho.values .= 0

        step!(charge_interp)
        step!(comm_rho)
        step!(field_solve)
        step!(comm_phi)
        step!(finite_diff)
        step!(comm_Eedge)
        step!(elec_ave)
        step!(comm_Enode)
        step!(push)
        step!(comm_electrons)
    end

    freqs = fftfreq(n_steps, 1 / dt) .* 2pi
    freq_amps = abs.(fft(electric_field_energy))

    freq_amps[1] = 0
    max_index = findmax(freq_amps)[2]
    max_freq = freqs[max_index]
    plasma_freq = abs(max_freq / 2)

    return plasma_freq
end</code></pre><pre><code class="nohighlight hljs">measure_plasma_frequency (generic function with 1 method)</code></pre><p>For a warm plasma, the thermal pressure acts as an additional restoring force on the plasma oscillation. It can be show that the modified dispersion relation (frequency response as a function of wavenumber) is given by</p><p class="math-container">\[\omega^2 = \omega_{p,e}^2 + \frac{3 k_B T_e}{m_e} k^2.\]</p><p>Notice that when <span>$T_e = 0$</span>, the frequency is the plasma frequency, regardless of the wavenumber.</p><p>Let&#39;s run a few simulations and verify that this relationship holds.</p><pre><code class="language-julia hljs">temperatures = [0, 0.1, 1, 10]
measure_plasma_frequency.(1e14, temperatures, 1 / 2 * pi)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Float64}:
 5.654866776461627e8
 5.654866776461627e8
 5.654866776461627e8
 3.1415926535897934e8</code></pre><p>We can compare this to the expected result.</p><pre><code class="language-julia hljs">function warm_plasma_freq(number_density, temperature, wavenumber)
    epsilon_0 = 8.8e-12
    elec_charge = 1.6e-19
    elec_mass = 9e-31
    boltzmann_constant = 1.381e-23
    square_plasma_freq = number_density * elec_charge^2 / elec_mass / epsilon_0
    correction_factor = boltzmann_constant * temperature * wavenumber^2 / elec_mass
    return sqrt(square_plasma_freq + correction_factor)
end
warm_plasma_freq.(1e14, temperatures, 1 / 2 * pi)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Float64}:
 5.685352436149611e8
 5.685352436182908e8
 5.685352436482581e8
 5.685352439479299e8</code></pre><p>Clearly, the restoring force of the pressure is not large enough to make a difference in this case.</p><hr/><p><em>This page was generated using <a href="https://github.com/JuliaDocs/DemoCards.jl">DemoCards.jl</a> and <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Introduction</a><a class="docs-footer-nextpage" href="../../">Example Gallery »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/adamslc/ParticleInCell2.jl">ParticleInCell2.jl</a> v1.0.0-DEV</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 15 January 2024 20:48">Monday 15 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
