var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"examples/electrostatic/landau_damping/#Landau-damping","page":"Landau damping","title":"Landau damping","text":"","category":"section"},{"location":"examples/electrostatic/landau_damping/","page":"Landau damping","title":"Landau damping","text":"(Image: Source code) (Image: notebook)","category":"page"},{"location":"examples/electrostatic/landau_damping/","page":"Landau damping","title":"Landau damping","text":"Coming soon...","category":"page"},{"location":"examples/electrostatic/landau_damping/","page":"Landau damping","title":"Landau damping","text":"","category":"page"},{"location":"examples/electrostatic/landau_damping/","page":"Landau damping","title":"Landau damping","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Grids","page":"Manual","title":"Grids","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"AbstractGrid\nUniformCartesianGrid","category":"page"},{"location":"manual/#ParticleInCell2.AbstractGrid","page":"Manual","title":"ParticleInCell2.AbstractGrid","text":"Parent type for all grid objects, which are used to define the simulation domain, and to convert between coordinate systems. There are three different numbering systems that can refer to a location in the simulation domain:\n\nThe 'physical coordinates' of a point are the real (dimensionalful) coordinates associated with that point. This value can range from the lower bounds to the upper bounds of the simulation. This value will typically take the form Vector{T} or NTuple{N, T} where T <: Real.\nThe 'cell coordinates' of a point is the non-dimensional location of the point in units of cell lengths. This value can range from 0 to num_cells - 1, or outside this range if guard cells are included. The value will typically have the type NTuple{N, Int}.\nThe 'cell index' of a point is the CartesianIndex that can be used to index into field arrays at that point. This value must strictly be confined to axes(field.values), which, for any given dimension, will typically range from 1 to numcells + 2*numguard_cells + 1.\n\nThe first two types of indexing, physcoords and cellcoords, are independent of the number of guard cells in a given field, and depend only on grid quantities. Thus utilities for converting between these systems require only a reference to a grid object. On the other hand, the utilities for cell_index are specific the field being used, and thus those must be provided an AbstractField to do the coordinate conversion.\n\nIn general, physical coordinates are useful when considering the location of a particle, while the cell index is used to interpolate to and from the particle locations. The cell coordinates are useful for some interpolation algorithms, especially those that are defined for non-uniform grids.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell2.UniformCartesianGrid","page":"Manual","title":"ParticleInCell2.UniformCartesianGrid","text":"UniformCartesianGrid(lower_bounds, upper_bounds, num_cells, periodic)\n\nThe simplest grid type, which represents a set of equally spaced rectangular cells. The grid can optionally be periodic in one or more dimensions.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Grid-utility-functions","page":"Manual","title":"Grid utility functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ParticleInCell2.cell_lengths\nParticleInCell2.sim_lengths\nParticleInCell2.cell_coords_to_phys_coords\nParticleInCell2.phys_coords_to_cell_coords","category":"page"},{"location":"manual/#ParticleInCell2.cell_lengths","page":"Manual","title":"ParticleInCell2.cell_lengths","text":"cell_lengths(grid, [cell_coords])\n\nReturns the length of the cell located at cell_coords. For uniform grids, the cell_coords argument is optional.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell2.sim_lengths","page":"Manual","title":"ParticleInCell2.sim_lengths","text":"sim_lengths(grid)\n\nReturns a tuple of the length of the simulation domain in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell2.cell_coords_to_phys_coords","page":"Manual","title":"ParticleInCell2.cell_coords_to_phys_coords","text":"cell_coords_to_phys_coords(grid, idxs, [offset, component])\n\nConverts the cell coordinates idxs to a physical coordinate using the geometry specified in grid. Optionally, an offset and component can be specified to get the physical coordinates of a specific edge or face of the cell. The component argument is one-indexed.\n\nFor more information on the different types of coordinate systems, see AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell2.phys_coords_to_cell_coords","page":"Manual","title":"ParticleInCell2.phys_coords_to_cell_coords","text":"phys_coords_to_cell_coords(grid, xs)\n\nConverts the physical coordinate xs to a grid coordinate using the geometry specified in grid.\n\nFor more information on the different types of coordinate systems, see AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Fields-and-species","page":"Manual","title":"Fields and species","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Field\nSpecies","category":"page"},{"location":"manual/#ParticleInCell2.Field","page":"Manual","title":"ParticleInCell2.Field","text":"Field(grid, offset, num_elements,[ lower_guard_cells = 0,\n    [upper_guard_cells = lower_guard_cells + 1]])\n\nStores the values of a field.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell2.Species","page":"Manual","title":"ParticleInCell2.Species","text":"Stores the positions and momentums of particles that share a common charge and mass. Each particle can have a different weight.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Update-steps","page":"Manual","title":"Update steps","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ParticleInCell2.AbstractUpdateStep\nstep!","category":"page"},{"location":"examples/electrostatic/beam_cyclotron/#Beam-cyclotron-instability","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"","category":"section"},{"location":"examples/electrostatic/beam_cyclotron/","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"(Image: Source code) (Image: notebook)","category":"page"},{"location":"examples/electrostatic/beam_cyclotron/","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"Coming soon...","category":"page"},{"location":"examples/electrostatic/beam_cyclotron/","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"","category":"page"},{"location":"examples/electrostatic/beam_cyclotron/","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/electrostatic/two_stream/#Two-stream-instability","page":"Two-stream instability","title":"Two-stream instability","text":"","category":"section"},{"location":"examples/electrostatic/two_stream/","page":"Two-stream instability","title":"Two-stream instability","text":"(Image: Source code) (Image: notebook)","category":"page"},{"location":"examples/electrostatic/two_stream/","page":"Two-stream instability","title":"Two-stream instability","text":"Coming soon...","category":"page"},{"location":"examples/electrostatic/two_stream/","page":"Two-stream instability","title":"Two-stream instability","text":"","category":"page"},{"location":"examples/electrostatic/two_stream/","page":"Two-stream instability","title":"Two-stream instability","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"theory/intro_to_pic/#Introduction-to-particle-in-cell-simulation","page":"PIC simulation","title":"Introduction to particle-in-cell simulation","text":"","category":"section"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"Classical plasma physics considers the motion of charged particles. The dynamics of these particles will be effected by the presence of externally imposed electric and magnetic fields, which is relatively easy to model since the motion of each particle is independent. However, the particles will themselves source an electric field–-and, if they are moving fast enough, a magnetic field–-due to their charge. The dynamics of other particles will be influenced by these 'self-consistent' fields, which corresponding source fields of their own. Thus, the dynamics of all of the particles is coupled, and so their equations of motion must be solve together. For a typical plasma, the resulting differential equations cannot be solved analytically, and the number of degrees of freedom means that direct computational integration of the equations is also impossible. Thus, plasma physics relies on various simplifications and assumptions to create reduced models that can be solved–- either exactly, or approximately.","category":"page"},{"location":"theory/intro_to_pic/#Approximations-to-the-true-particle-distribution-function","page":"PIC simulation","title":"Approximations to the true particle distribution function","text":"","category":"section"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"It is convenient to represent the locations and momenta of the particles using the distribution function","category":"page"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"f(xpt) = sum_i=1^N delta(x - x_i(t)) delta(p - p_i(t))","category":"page"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"where N is the total number of particles. The evolution of this distribution function can be written using the Maxwell-Boltzmann system","category":"page"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"beginaligned\nTODO\nTODO-Maxwell\nendaligned","category":"page"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"Unfortunately, for almost all plasmas of interest, N is enormous; thus direct simulation of the equations of motion is computationally intractable. The solution is to recognize that if N is large, then any physically small phase-space region will contain many particles, and so we c","category":"page"},{"location":"theory/intro_to_pic/#Todo","page":"PIC simulation","title":"Todo","text":"","category":"section"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"course-graining\ncollisionless plasmas\nbriefly mention thermalization, two-fluid, and MHD","category":"page"},{"location":"theory/intro_to_pic/#Discretized-solutions-of-the-Boltzmann-Poisson-equations","page":"PIC simulation","title":"Discretized solutions of the Boltzmann-Poisson equations","text":"","category":"section"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"We have seen that a kinetic plasma can be approximated using the Vlasov-Boltzmann equation, along with an appropriate equation of motion for the electromagnetic fields. However, the resulting equation is still not easy to analyse for an arbitrary f. We therefore turn to computational simulation of the equations of motion to understand the plasma dynamics.","category":"page"},{"location":"theory/intro_to_pic/","page":"PIC simulation","title":"PIC simulation","text":"In order to simulate the plasma, we must first discretize the equations so they can be represented on a computer. One option, called a Vlasov code, represents the distribution function as","category":"page"},{"location":"theory/intro_to_pic/#The-standard-PIC-cycle","page":"PIC simulation","title":"The standard PIC cycle","text":"","category":"section"},{"location":"examples/#Example-Gallery","page":"Example Gallery","title":"Example Gallery","text":"","category":"section"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"These examples are in progress...","category":"page"},{"location":"examples/#Electrostatic","page":"Example Gallery","title":"Electrostatic","text":"","category":"section"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card-section\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"(Image: list-card-cover-image)","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Two-stream instability","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Coming soon...","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"(Image: list-card-cover-image)","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Beam-plasma instability","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Coming soon...","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"(Image: list-card-cover-image)","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Beam-cyclotron instability","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Coming soon...","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"(Image: list-card-cover-image)","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Landau damping","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Coming soon...","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>","category":"page"},{"location":"examples/#Electromagnetic","page":"Example Gallery","title":"Electromagnetic","text":"","category":"section"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card-section\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"(Image: list-card-cover-image)","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Beam heating","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"Coming soon...","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"examples/","page":"Example Gallery","title":"Example Gallery","text":"</div>","category":"page"},{"location":"examples/electromagnetic/beam_heating/#Beam-heating","page":"Beam heating","title":"Beam heating","text":"","category":"section"},{"location":"examples/electromagnetic/beam_heating/","page":"Beam heating","title":"Beam heating","text":"(Image: Source code) (Image: notebook)","category":"page"},{"location":"examples/electromagnetic/beam_heating/","page":"Beam heating","title":"Beam heating","text":"Coming soon...","category":"page"},{"location":"examples/electromagnetic/beam_heating/","page":"Beam heating","title":"Beam heating","text":"","category":"page"},{"location":"examples/electromagnetic/beam_heating/","page":"Beam heating","title":"Beam heating","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"theory/#Plasma-Simulation-Theory","page":"Introduction","title":"Plasma Simulation Theory","text":"","category":"section"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"The fundamental physics governing the dynamics of a plasma have been well understood for over a century, and yet plasma physics remains an active area of research. This is because the dynamics of a plasma are highly nonlinear, and it is therefore difficult to make analytic statements about how a given plasma will behave over long time-spans. Instead, theoretical plasma physicists often rely on simulation to understand plasma dynamics, and to make general statements about the behaviors of particular classes of plasmas.","category":"page"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"Unfortunately, the simulation of plasmas is itself a quite challenging task because plasmas are composed of many, many, charged particles. As a result, there are far too many degrees of freedom to exactly solve the full equations of motion for a given plasma. Instead, physicists rely on approximations to derive physically relevant models for the systems in question.","category":"page"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"The most \"realistic\" class of models are called kinetic models. In these models, the individual charged particles of each species are averaged to create distribution functions that depends on both position and velocity. The distribution functions give the likelihood of finding a charged particle of a particular species at any point in phase space. These distribution functions, along with a method for calculating the self-consistent interaction between the particles, yields a set of approximate equations of motion describing the plasma dynamics.","category":"page"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"If the particle species are nonrelativistic, then the particles are not influenced by self-consistent magnetic fields, and so the interactions can be modeled using electrostatics. However, once the particles (typically the lightweight electrons) become relativistic, the sourced magnetic field must be taken into account, and so full electromagnetic interactions are required.","category":"page"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"Over long periods of time, the plasma will begin to thermalize–-the distribution of particle velocities will become closer and closer to Maxwellian. This fact can be used to drastically improve the size and speed of simulations by using the two-fluid and magnetohydrodynamic (MHD) approximations of plasma dynamics. As this package does not implement algorithms for these simulation methods, we will not discuss the details of these methods further.","category":"page"},{"location":"theory/","page":"Introduction","title":"Introduction","text":"In the following sections, we describe the details of particle-in-cell algorithms, a specific type of kinetic simulation algorithm. For a more in depth introduction of PIC simulation theory, see the books by Birdsall and Langdon (2004) and Hockney and Eastwood (1989).","category":"page"},{"location":"examples/electrostatic/beam_plasma/#Beam-plasma-instability","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"","category":"section"},{"location":"examples/electrostatic/beam_plasma/","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"(Image: Source code) (Image: notebook)","category":"page"},{"location":"examples/electrostatic/beam_plasma/","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"Coming soon...","category":"page"},{"location":"examples/electrostatic/beam_plasma/","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"","category":"page"},{"location":"examples/electrostatic/beam_plasma/","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"#ParticleInCell2.jl","page":"Introduction","title":"ParticleInCell2.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ParticleInCell2","category":"page"},{"location":"#ParticleInCell2","page":"Introduction","title":"ParticleInCell2","text":"ParticleInCell2.jl is a Julia package for kinetic plasma physics simulation. Specifically, it focuses on the simulation of kinetic (non-thermal) plasmas using particle-in-cell (PIC) algorithms. Currently, this package is in in a pre-1.0.0 state, and thus breaking changes should be expected. However, this also means that I am willing to entertain radical suggestions to improve the functionality of the package. If you are interested in using ParticleInCell2 for your plasma research, and you find that it does not meet you needs, please reach out on either GitHub, or over email, so that we can discuss how the package can be modified to suite your needs.\n\nGetting Started\n\nParticleInCell2 is currently not registered in the Julia package registry. Thus, to install this package, you should use Pkg.develop:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/adamslc/ParticleInCell2.jl\")\n\nDocumentation\n\nYou can view the latest documentation here.\n\nGoals\n\nFast: aim to have core time of less than 1 microsecond per particle per step without collisions.\nFlexible: it should be possible to implement essentially any kinetic plasma simulation in ParticleInCell2.jl. For common types of simulations, this might mean just piecing together components that are already included. More esoteric problems might require writing custom types that implement the desired algorithms. The advantage of writing this package in Julia is that these custom types will be just as performant as native components that are included in the package.\nScalable: the eventual goal is to enable scaling across an essentially unlimited number of cores using Julia's native multithreading for parallelization on a single node, and MPI.jl for communication across nodes. The goal is to support two different modes of parallelization:\nEach core is responsible for a single rectangular subdomain. The domain assigned to an entire node is also rectangular, which imposes constraints on how the node domain can be subdivided into subdomains for each core. Load balancing is achieved by varying the relative sizes of the domains such that each core has a similar amount of work per step.\nThe simulation domain is subdivided into subdomains called 'patches', and every node is assigned a list of patches that it is responsible for updating. The cores on each node work collaboratively on the list, each choosing one patch to work on, and then selecting another when they are finished. Load balancing is achieved by swapping patches between nodes to balance the workload while also seeking to minimize communication time by keeping the surface area of each node's responsibilities minimized. In order for this scheme to effectively load balance, it must be the case that the total number of patches is larger (ideally much larger) that the total number of cores.\n\n\n\n\n\n","category":"module"},{"location":"#Documentation-sections","page":"Introduction","title":"Documentation sections","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started, look at the Tutorial, which includes step-by-step instructions for running your first simulation using ParticleInCell2. After that, you may want to browse the Example Gallery, to see other problems that this package can be used to solve. The Plasma Simulation Theory section contains information about the art of computational plasma physics, and the numerical constraints that require the specialized tools developed here. Finally, the Manual contains detailed information about the entire public interface of the package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../literate_src/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: Tip\nYou can also view this tutorial as a Jupyter notebook or you can download the plain Julia script.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial will get you up and running using ParticleInCell2 by showing you how to model one of the simplest phenomena in plasma physics: an electrostatic (or Langmuir) oscillation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A Langmuir oscillation occurs when a slab of charge in a uniform plasma is displaced. The resulting charge density gradient creates a restoring force that causes the displaced slab of charge to return to its original position. But–-just as in a classical pendulum oscillation–-the momentum of the charge carries it past its equilibrium point, creating an opposite charge gradient, and a restoring force in the opposite direction. As a result, the slab of charge oscillates around its equilibrium forever (at least in this idealized model that ignores possible damping mechanisms).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To start using ParticleInCell2, we must first install and load the package. As the package is not currently registered in Julia's General registry, we will using Pkgs develop function. We will also need the StaticArrays package, so we load that now.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.develop(url = \"https://github.com/adamslc/ParticleInCell2.jl\")\nusing ParticleInCell2\nusing StaticArrays","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to simulate a plasma, we need to define a domain in which the simulation will take place. Because Langmuir oscillations are a one-dimensional phenomena, we will choose to perform a 1D simulation. We arbitrarily choose to set the length of the simulation domain to 1, and we choose to use 32 equally spaced (i.e. uniform) grid points. Additionally, we make the simulation domain periodic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sim_length = 1.0\nnum_cells = 32\nperiodic = true\ngrid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (periodic,));\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we set up the required fields for an electrostatic PIC simulation. In a basic PIC cycle, we first compute the charge density, rho, on the grid points. We then compute the corresponding electric potential, phi. The electric field is conventionally determined in a two step process. First the potential, which is locatated at the nodes of the grid cells, is finite differenced to the edges of the cells, producing an edge electric field, Eedge. The edge electric fields are then averaged to get the electric fields located at the nodes, Enode.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When creating the fields, we must specify the underlying grid on which the field is based, the location of the values of the field (i.e. are the field values located at the nodes of each cell? The edge?), the dimension of the field, and the number of guard cells surrounding the field.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"field_dimension = 1\nlower_guard_cells = 1\nrho = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)\nphi = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells)\nEedge = Field(grid, ParticleInCell2.edge, field_dimension, lower_guard_cells)\nEnode = Field(grid, ParticleInCell2.node, field_dimension, lower_guard_cells);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we need to create some macroparticles to move in the simulation. In this example, we only consider mobile electrons. In order to seed a Langmuir oscillation, we give the electrons a sinusoidal velocity perturbation. Currently, the creation of a new particle species, and the specification of all of the initial conditions is a quite manual process. In the future, this will be streamlined.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nom_density = 1e14\ndx = sim_length / num_cells\nnum_particles = num_cells * 10\nparticles_per_macro = nom_density * sim_length / num_particles\nk = 1\namplitude = 1e3\nthermal_amp = 0.0\n\nepsilon_0 = 8.8e-12\ncharge = 1.6e-19 * particles_per_macro\nmass = 9e-31 * particles_per_macro\n\npositions = Vector{SVector{1,Float64}}(undef, num_particles)\nmomentums = Vector{SVector{1,Float64}}(undef, num_particles)\nweights = Vector{Float64}(undef, num_particles)\n\nfor i in eachindex(positions)\n    positions[i] = SVector((i - 1) / num_particles)\n    momentums[i] = SVector(\n        mass * (amplitude * sin((i - 1) / num_particles * k * 2pi) + thermal_amp * randn()),\n    )\n    weights[i] = 1.0\nend\nelectrons = Species(positions, momentums, weights, charge, mass);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the final step of the setup, we create all of the simulation steps required to do the electrostatic simulation. In this tutorial, we will not discuss the details of PIC simulation, but you can find more information about the PIC simulation cycle elsewhere in this documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Also at this point, we must choose a timestep for the simulation. The choice of a timestep is a nuanced decision that balances limited compute time (which encourages a longer timestep, so that more of the systems dynamics can be observed with the same number of steps) with the physical and numerical constraints imposed by the system, and the simulation method. In this case, the physical constraint is that we must resolve the plasma frequency (the frequency of the charge slab's oscillation) and the numerical constraint is that we must respect the CFL condition, which says that particles may not cross more than one cell per timestep.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 1.11e-11 * 2\n\ncharge_interp = BSplineChargeInterpolation(electrons, rho, 1)\ncomm_rho = CommunicateGuardCells(rho, true)\nfield_solve = PoissonSolveFFT(rho, phi)\ncomm_phi = CommunicateGuardCells(phi)\nfinite_diff = FiniteDifferenceToEdges(phi, Eedge)\ncomm_Eedge = CommunicateGuardCells(Eedge)\nelec_ave = AverageEdgesToNodes(Eedge, Enode)\ncomm_Enode = CommunicateGuardCells(Enode)\npush = ElectrostaticParticlePush(electrons, Enode, dt)\ncomm_electrons = CommunicateSpecies(electrons, grid);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we are ready to run the simulation. We will simulate the plasma for 1000 timesteps, and at each step, we will calculate the electric field energy,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U_E = int E(x)^2 mathrmdx","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This field energy will oscillate as the electrons move in and out of equilibrium, and so we can use it to observe the Langmuir oscillation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_steps = 1000\n\nelectric_field_energy = Vector{Float64}(undef, n_steps)\n\nfor n = 1:n_steps\n    # Calculate the electric field energy\n    electric_field_energy[n] = 0\n    for I in eachindex(Enode)\n        electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2\n    end\n\n    # TODO\n    rho.values .= 0\n\n    step!(charge_interp)\n    step!(comm_rho)\n    step!(field_solve)\n    step!(comm_phi)\n    step!(finite_diff)\n    step!(comm_Eedge)\n    step!(elec_ave)\n    step!(comm_Enode)\n    step!(push)\n    step!(comm_electrons)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now visualize the electric field energy to see the plasma oscillation. We will use CairoMakie which is a backend for Makie that can generate beautiful, publication-quality graphics. First we load the package, and set it to generate inline svg images.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then plot the field energy.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"times = collect(range(1, n_steps)) .* dt\nlines(\n    times,\n    electric_field_energy;\n    axis = (; title = \"Electric Field Energy\", xlabel = \"Time (s)\", ylabel = \"Energy\"),\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that the electric field energy is slowly growing over time. This is a result of the \"grid-heating instability\". In this instability, a plasma with a Debye length (the characteristic length with which the plasma will screen an applied electric field) shorter than the cell size will be unphysically heated until the Debye length is comparable to the cell size. Because we initialized the electrons with only a sinusoidal velocity perturbation, and no thermal spread in the velocity distribution, the Debye length is effectively zero, and thus the simulation suffers from grid heating.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Despite this unphysical effect, we can still use the electric field energy time series to calculate the plasma frequency by computing its Fourier transform. First, let's plot the Fourier transform.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FFTW\n\nfreqs = fftfreq(n_steps, 1 / dt) .* 2pi\nfreq_amps = abs.(fft(electric_field_energy))\n\nlines(\n    freqs,\n    freq_amps;\n    axis = (;\n        title = \"Electric Field Energy Frequency Spectrum\",\n        xlabel = \"Frequency (1/s)\",\n        ylabel = \"Amplitude\",\n    ),\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is hard to see what is happening at the low frequencies, so let's zoom in on the positive low frequencies.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cutoff_index = round(Int, n_steps * 0.05)\nlines(\n    freqs[1:cutoff_index],\n    freq_amps[1:cutoff_index];\n    axis = (;\n        title = \"Electric Field Energy Frequency Spectrum\",\n        xlabel = \"Frequency (1/s)\",\n        ylabel = \"Amplitude\",\n    ),\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we find the maximum frequency. We don't care about the spike at zero frequency (that is just a consequence of the grid heating that we discussed earlier) so we first set its amplitude to zero, and then find the largest remaining amplitude, and it's corresponding frequency.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"freq_amps[1] = 0\nmax_index = findmax(freq_amps)[2]\nmax_freq = freqs[max_index]\n\n# Divide by 2 because the electric field energy goes through a maximum twice\n# per plasma oscillation\nplasma_freq = max_freq / 2","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can compare this to the theoretically expected result:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"elec_charge = 1.6e-19\nelec_mass = 9e-31\ntheory_plasma_freq = sqrt(nom_density * elec_charge^2 / elec_mass / epsilon_0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As you can see, these two results agree fairly closely, indicating that our simulation has captured the essential physics that the theory predicts.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
