var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"Birdsall, C. K. and Langdon, A. B. (2004). Plasma Physics via Computer Simulation. 1 edition Edition (CRC Press).\n\n\n\nBoris, J. P. (1970). Relativistic plasma simulation-optimization of a hybrid code. Proceeding of Fourth Conference on Numerical Simulations of Plasmas, 3–8.\n\n\n\nHockney, R. W. and Eastwood, J. W. (1989). Computer Simulation Using Particles. First Edition Edition (CRC Press).\n\n\n\n","category":"section"},{"location":"examples/electrostatic/landau_damping/#Landau-damping","page":"Landau damping","title":"Landau damping","text":"(Image: Source code) (Image: notebook)\n\nComing soon...\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Grids","page":"Manual","title":"Grids","text":"","category":"section"},{"location":"manual/#Grid-utility-functions","page":"Manual","title":"Grid utility functions","text":"","category":"section"},{"location":"manual/#Species","page":"Manual","title":"Species","text":"","category":"section"},{"location":"manual/#Species-utility-functions","page":"Manual","title":"Species utility functions","text":"","category":"section"},{"location":"manual/#Fields","page":"Manual","title":"Fields","text":"","category":"section"},{"location":"manual/#Update-steps","page":"Manual","title":"Update steps","text":"ParticleInCell.AbstractUpdateStep\nstep!","category":"section"},{"location":"manual/#Misc","page":"Manual","title":"Misc","text":"","category":"section"},{"location":"manual/#ParticleInCell.AbstractGrid","page":"Manual","title":"ParticleInCell.AbstractGrid","text":"Parent type for all grid objects, which are used to define the simulation domain, and to convert between coordinate systems. There are three different numbering systems that can refer to a location in the simulation domain:\n\nThe 'physical coordinates' of a point are the real (dimensionalful) coordinates associated with that point. This value can range from the lower bounds to the upper bounds of the simulation. This value will typically take the form Vector{T} or NTuple{N, T} where T <: Real.\nThe 'cell coordinates' of a point is the non-dimensional location of the point in units of cell lengths. This value can range from 0 to num_cells - 1, or outside this range if guard cells are included. The value will typically have the type NTuple{N, Int} or NTuple{N, T} with T <: Real.\nThe 'cell index' of a point is the CartesianIndex that can be used to index into field arrays at that point. This value must strictly be confined to axes(field.values), which, for any given dimension, will typically range from 1 to numcells + 2*numguard_cells + 1.\n\nThe first two types of indexing, physcoords and cellcoords, are independent of the number of guard cells in a given field, and depend only on grid quantities. Thus utilities for converting between these systems require only a reference to a grid object. On the other hand, the utilities for cell_index are specific the field being used, and thus those must be provided an AbstractField to do the coordinate conversion.\n\nIn general, physical coordinates are useful when considering the location of a particle, while the cell index is used to interpolate to and from the particle locations. The cell coordinates are useful for some interpolation algorithms, especially those that are defined for non-uniform grids.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.UniformCartesianGrid","page":"Manual","title":"ParticleInCell.UniformCartesianGrid","text":"UniformCartesianGrid(lower_bounds, upper_bounds, num_cells, periodic)\n\nThe simplest grid type, which represents a set of equally spaced rectangular cells. The grid can optionally be periodic in one or more dimensions.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.cell_lengths","page":"Manual","title":"ParticleInCell.cell_lengths","text":"cell_lengths(grid, [cell_coords])\n\nReturns the length of the cell located at cell_coords. For uniform grids, the cell_coords argument is optional.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.sim_lengths","page":"Manual","title":"ParticleInCell.sim_lengths","text":"sim_lengths(grid)\n\nReturns a tuple of the length of the simulation domain in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.cell_coords_to_phys_coords","page":"Manual","title":"ParticleInCell.cell_coords_to_phys_coords","text":"cell_coords_to_phys_coords(grid, idxs)\n\nConverts the cell coordinates idxs to a physical coordinate using the geometry specified in grid.\n\nFor more information on the different types of coordinate systems, see AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.phys_coords_to_cell_coords","page":"Manual","title":"ParticleInCell.phys_coords_to_cell_coords","text":"phys_coords_to_cell_coords(grid, xs)\n\nConverts the physical coordinate xs to a grid coordinate using the geometry specified in grid.\n\nFor more information on the different types of coordinate systems, see AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.AbstractSpecies","page":"Manual","title":"ParticleInCell.AbstractSpecies","text":"Subtypes of AbstractSpecies represent a group of macroparticles with a single physical charge and mass. Each particle of a species can optionally represent a different number of physical particles.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.VariableWeightSpecies","page":"Manual","title":"ParticleInCell.VariableWeightSpecies","text":"VariableWeightSpecies(positions::Matrix, momentums::Matrix, weight::Vector charge, mass)\n\nStores the positions and momentums of particles that share a common charge and mass. Each particle can have a different weight, and the momentum space can have a larger dimension than the position space.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.electrons","page":"Manual","title":"ParticleInCell.electrons","text":"electrons(positions::Matrix, momentums::Matrix, weights::Vector)\nelectrons(positions::Matrix, momentums::Matrix, weight)\n\nCreates an AbsractSpecies with the given positions, momentums, and weight, and the charge and mass of a single electron.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_charge","page":"Manual","title":"ParticleInCell.particle_charge","text":"particle_charge(species, idx)\n\nReturns the charge of the macroparticle of species with index idx. See also physical_charge.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.physical_charge","page":"Manual","title":"ParticleInCell.physical_charge","text":"physical_charge(species, idx)\n\nReturns the charge of a physical particle represented by the macroparticle of species with index idx. See also particle_charge.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_mass","page":"Manual","title":"ParticleInCell.particle_mass","text":"particle_mass(species, idx)\n\nReturns the mass of the macroparticle of species with index idx. See also physical_mass.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.physical_mass","page":"Manual","title":"ParticleInCell.physical_mass","text":"physical_mass(species, idx)\n\nReturns the mass of a physical particle represented by the macroparticle of species with index idx. See also particle_charge.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_weight","page":"Manual","title":"ParticleInCell.particle_weight","text":"particle_weight(species, idx)\n\nReturns the number of  physical particles represented by the macroparticle of species with index idx.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_position","page":"Manual","title":"ParticleInCell.particle_position","text":"particle_position(species, idx)\n\nReturns the position of the macroparticle of species with index idx. See also particle_momentum and particle_position!.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_position!","page":"Manual","title":"ParticleInCell.particle_position!","text":"particle_position!(species, idx, value)\n\nSets the position of the macroparticle of species with index idx to value. See also particle_momentum! and particle_position.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_momentum","page":"Manual","title":"ParticleInCell.particle_momentum","text":"particle_momentum(species, idx)\n\nReturns the momentum of the macroparticle of species with index idx. See also particle_momentum!, particle_velocity, and physical_momentum.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_momentum!","page":"Manual","title":"ParticleInCell.particle_momentum!","text":"particle_momentum!(species, idx, value)\n\nSets the momentum of the macroparticle of species with index idx to value. See also particle_momentum, particle_velocity, and physical_momentum.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.particle_velocity","page":"Manual","title":"ParticleInCell.particle_velocity","text":"particle_velocity(species, idx)\n\nReturns the velocity of the macroparticle of species with index idx. See also particle_momentum, particle_momentum!, and physical_momentum.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.physical_momentum","page":"Manual","title":"ParticleInCell.physical_momentum","text":"physical_momentum(species, idx)\n\nReturns the momentum of a physical particle represented by the macroparticle of species with index idx. See also particle_momentum, particle_momentum!, and particle_velocity.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Base.eachindex","page":"Manual","title":"Base.eachindex","text":"eachindex(species)\n\nReturns an iterator to the index of each of the macroparticles contained in species.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.Field","page":"Manual","title":"ParticleInCell.Field","text":"Field(grid, offset, num_elements,[ lower_guard_cells = 0,\n    [upper_guard_cells = lower_guard_cells + 1]])\n\nStores the values of a field.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.ElectrostaticParticlePush","page":"Manual","title":"ParticleInCell.ElectrostaticParticlePush","text":"ElectrostaticParticlePush(species, E, timestep, [interpolation_order=1])\n\nAn update step that moves and accelerates particles of species according to the electric field E. The field will be interpolated to the particle positions using b-splines of interpolation_order.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.BorisParticlePush","page":"Manual","title":"ParticleInCell.BorisParticlePush","text":"BorisParticlePush(species, E, B, timestep)\n\nThis update step moves the particles of species subject to both an electric field, E, and a magnetic field, B. The method is frequently referred to by the shorthand accelerate-rotate-accelerate because the acceleration from the electric field is split in half, and applied before and after the magnetic field rotation.\n\nAn applied magnetic field forces charged particles to travel in circular orbits perpendicular to the magnetic field. Thus, a simulation using the Boris method only makes sense when there are at least two velocity components, and in this case, the applied magnetic field must be strictly perpendicular to the velocity components. So for example, one could have a 1d2v simulation with a spatial grid along the x-axis, and velocity components in the x and y directions. In this case, the magnetic field would be forced to point along the z axis. If all three velocity components are included in the simulation, then the magnetic field can point in any direction.\n\nFor more details on the method, see Sections 4.3 and 4.4 of Birdsall and Langdon, or the Boris' original conference proceedings.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.LinearSolveStep","page":"Manual","title":"ParticleInCell.LinearSolveStep","text":"Solves the linear equation A x = b where x and b are fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ParticleInCell.compute_knots","page":"Manual","title":"ParticleInCell.compute_knots","text":"compute_knots(degree)\n\nReturns a vector of the knot locations for a polynomial b-spline with degree.\n\n\n\n\n\n","category":"function"},{"location":"manual/#ParticleInCell.compute_bspline_coeffs","page":"Manual","title":"ParticleInCell.compute_bspline_coeffs","text":"compute_bspline_coeffs(degree, [T])\n\nReturns a vector of vectors of the coefficients for the b-spline with polynomial degree, and unit-spaced knots, centered at zero.\n\n\n\n\n\n","category":"function"},{"location":"examples/electrostatic/beam_cyclotron/#Beam-cyclotron-instability","page":"Beam-cyclotron instability","title":"Beam-cyclotron instability","text":"(Image: Source code) (Image: notebook)\n\nComing soon...\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/electrostatic/two_stream/#Two-stream-instability","page":"Two-stream instability","title":"Two-stream instability","text":"(Image: Source code) (Image: notebook)\n\nComing soon...\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"theory/intro_to_pic/#Introduction-to-particle-in-cell-simulation","page":"PIC simulation","title":"Introduction to particle-in-cell simulation","text":"Classical plasma physics considers the motion of charged particles. The dynamics of these particles will be effected by the presence of externally imposed electric and magnetic fields, which is relatively easy to model since the motion of each particle is independent. However, the particles will themselves source an electric field–-and, if they are moving fast enough, a magnetic field–-due to their charge. The dynamics of other particles will be influenced by these 'self-consistent' fields, which corresponding source fields of their own. Thus, the dynamics of all of the particles is coupled, and so their equations of motion must be solve together. For a typical plasma, the resulting differential equations cannot be solved analytically, and the number of degrees of freedom means that direct computational integration of the equations is also impossible. Thus, plasma physics relies on various simplifications and assumptions to create reduced models that can be solved–- either exactly, or approximately.","category":"section"},{"location":"theory/intro_to_pic/#Approximations-to-the-true-particle-distribution-function","page":"PIC simulation","title":"Approximations to the true particle distribution function","text":"It is convenient to represent the locations and momenta of the particles using the distribution function\n\nf(xpt) = sum_i=1^N delta(x - x_i(t)) delta(p - p_i(t))\n\nwhere N is the total number of particles. The evolution of this distribution function can be written using the Maxwell-Boltzmann system\n\nbeginaligned\nTODO\nTODO-Maxwell\nendaligned\n\nUnfortunately, for almost all plasmas of interest, N is enormous; thus direct simulation of the equations of motion is computationally intractable. The solution is to recognize that if N is large, then any physically small phase-space region will contain many particles, and so we c","category":"section"},{"location":"theory/intro_to_pic/#Todo","page":"PIC simulation","title":"Todo","text":"course-graining\ncollisionless plasmas\nbriefly mention thermalization, two-fluid, and MHD","category":"section"},{"location":"theory/intro_to_pic/#Discretized-solutions-of-the-Boltzmann-Poisson-equations","page":"PIC simulation","title":"Discretized solutions of the Boltzmann-Poisson equations","text":"We have seen that a kinetic plasma can be approximated using the Vlasov-Boltzmann equation, along with an appropriate equation of motion for the electromagnetic fields. However, the resulting equation is still not easy to analyse for an arbitrary f. We therefore turn to computational simulation of the equations of motion to understand the plasma dynamics.\n\nIn order to simulate the plasma, we must first discretize the equations so they can be represented on a computer. One option, called a Vlasov code, represents the distribution function as","category":"section"},{"location":"theory/intro_to_pic/#The-standard-PIC-cycle","page":"PIC simulation","title":"The standard PIC cycle","text":"","category":"section"},{"location":"examples/#Example-Gallery","page":"Example Gallery","title":"Example Gallery","text":"These examples are in progress...","category":"section"},{"location":"examples/#Tutorial","page":"Example Gallery","title":"Tutorial","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nTutorial: Langmuir oscillations\n\n</div>\n    <div class=\"list-card-description\">\n\nIn this tutorial, you will use ParticleInCell to model one of the simplest phenomena in plasma physics: an electrostatic (or Langmuir) oscillation. This tutorial is part of a series of examples that uses ParticleInCell to demonstrate the basic plasma physics concepts that are covered in Birdsall and Langdon's classic PIC textbook.\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>","category":"section"},{"location":"examples/#Electrostatic","page":"Example Gallery","title":"Electrostatic","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nTwo-stream instability\n\n</div>\n    <div class=\"list-card-description\">\n\nComing soon...\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nBeam-plasma instability\n\n</div>\n    <div class=\"list-card-description\">\n\nComing soon...\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nBeam-cyclotron instability\n\n</div>\n    <div class=\"list-card-description\">\n\nComing soon...\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nLandau damping\n\n</div>\n    <div class=\"list-card-description\">\n\nComing soon...\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>","category":"section"},{"location":"examples/#Electromagnetic","page":"Example Gallery","title":"Electromagnetic","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">\n\n(Image: list-card-cover-image)\n\n  </div></td>\n  <td><div class=\"list-card-text\">\n\nBeam heating\n\n</div>\n    <div class=\"list-card-description\">\n\nComing soon...\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>","category":"section"},{"location":"examples/electromagnetic/beam_heating/#Beam-heating","page":"Beam heating","title":"Beam heating","text":"(Image: Source code) (Image: notebook)\n\nComing soon...\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"theory/#Plasma-Simulation-Theory","page":"Introduction","title":"Plasma Simulation Theory","text":"The fundamental physics governing the dynamics of a plasma have been well understood for over a century, and yet plasma physics remains an active area of research. This is because the dynamics of a plasma are highly nonlinear, and it is therefore difficult to make analytic statements about how a given plasma will behave over long time-spans. Instead, theoretical plasma physicists often rely on simulation to understand plasma dynamics, and to make general statements about the behaviors of particular classes of plasmas.\n\nUnfortunately, the simulation of plasmas is itself a quite challenging task because plasmas are composed of many, many, charged particles. As a result, there are far too many degrees of freedom to exactly solve the full equations of motion for a given plasma. Instead, physicists rely on approximations to derive physically relevant models for the systems in question.\n\nThe most \"realistic\" class of models are called kinetic models. In these models, the individual charged particles of each species are averaged to create distribution functions that depends on both position and velocity. The distribution functions give the likelihood of finding a charged particle of a particular species at any point in phase space. These distribution functions, along with a method for calculating the self-consistent interaction between the particles, yields a set of approximate equations of motion describing the plasma dynamics.\n\nIf the particle species are nonrelativistic, then the particles are not influenced by self-consistent magnetic fields, and so the interactions can be modeled using electrostatics. However, once the particles (typically the lightweight electrons) become relativistic, the sourced magnetic field must be taken into account, and so full electromagnetic interactions are required.\n\nOver long periods of time, the plasma will begin to thermalize–-the distribution of particle velocities will become closer and closer to Maxwellian. This fact can be used to drastically improve the size and speed of simulations by using the two-fluid and magnetohydrodynamic (MHD) approximations of plasma dynamics. As this package does not implement algorithms for these simulation methods, we will not discuss the details of these methods further.\n\nIn the following sections, we describe the details of particle-in-cell algorithms, a specific type of kinetic simulation algorithm. For a more in depth introduction of PIC simulation theory, see the books by Birdsall and Langdon (2004) and Hockney and Eastwood (1989).","category":"section"},{"location":"examples/tutorial/langmuir_oscillation/#tutorial_langmuir","page":"Tutorial","title":"Tutorial: Langmuir oscillations","text":"(Image: Source code) (Image: notebook)\n\nIn this tutorial, you will use ParticleInCell to model one of the simplest phenomena in plasma physics: an electrostatic (or Langmuir) oscillation. This tutorial is part of a series of examples that uses ParticleInCell to demonstrate the basic plasma physics concepts that are covered in Birdsall and Langdon's classic PIC textbook.\n\nA Langmuir oscillation occurs when a slab of charge in a uniform plasma is displaced. The resulting charge density gradient creates a restoring force that causes the displaced slab of charge to return to its original position. But–-just as in a classical pendulum oscillation–-the momentum of the charge carries it past its equilibrium point, creating an opposite charge gradient, and a restoring force in the opposite direction. As a result, the slab of charge oscillates around its equilibrium forever (at least in this idealized model that ignores possible damping mechanisms). For a plasma composed of a single mobile species s with mass m_s and charge q_s, the frequency of this oscillation is given by\n\nomega_ps = sqrtfracn_s q_s^2epsilon_0 m_s\n\nwhere n_s is the number density of the plasma and epsilon_0 is the permitivity of free space. Notice that the plasma frequency has a m_s^-12 dependence, and thus the lightest species (typically electrons) will dominate the dynamics of a plasma oscillation. For this reason, we will only model the dynamics of the electrons in our simulation.","category":"section"},{"location":"examples/tutorial/langmuir_oscillation/#Simulating-a-cold-electron-plasma","page":"Tutorial","title":"Simulating a cold electron plasma","text":"We begin by loading the ParticleInCell package. Additionally, we load CairoMakie which is a backend for Makie that can generate beautiful, publication-quality graphics.\n\nusing ParticleInCell\nusing CairoMakie\ndocs_theme = Theme(\n    fontsize = 20,\n    fonts = (; regular = \"Lato\", bold = \"Lato Bold\"),\n    palette = (color = [:black, :red, :blue],),\n    Axis = (xgridvisible = false, ygridvisible = false),\n    Scatter = (; cycle = [:color]),\n    Lines = (; cycle = [:color]),\n)\n\nWe begin by creating some electrons to move in the simulation. For even a tiny simulation volume, there are far too many physical electrons to simulate each one individually. Instead, PIC algorithms group physical particles into 'macroparticles'. The distribution of macroparticles in phase space serves as an approximation for the phase space distribution of physical particles. We arbitrarily choose a simulation domain of length one, and a nominal electrons number density of 10^14. Then, for a given number of macroparticles, we can calculate the number of physical electrons represented by each.\n\nsim_length = 1.0\nnumber_density = 1e14\nnum_macroparticles = 320\nparticles_per_macro = number_density * sim_length / num_macroparticles\n\n3.125e11\n\nWe distribute the macroparticles evenly across the simulation domain.\n\npositions = collect(0:num_macroparticles-1) ./ num_macroparticles;\n\nIn order to seed a Langmuir oscillation, we give the electrons a sinusoidal velocity perturbation. This corresponds to the moment in a Langmuir oscillation when the slab of charge has reached equilibrium, but is being carried past by its momentum. This perturbation is defined by a wavenumber k and an amplitude.\n\nk = 1 * 2pi / sim_length\namplitude = 1e3\nelec_mass = 9e-31\nmomentums = (particles_per_macro * elec_mass * amplitude) .* sin.(positions .* k);\n\nWe can visualize the initial condition of the electron macroparticle by plotting the initial phase space.\n\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Electron phase space\",\n    xlabel = \"Position (m)\",\n    ylabel = \"Momentum (arb. units)\",\n    limits = ((0, 1), nothing),\n)\nscatter!(ax, positions, momentums ./ maximum(momentums))\nfig\n\n(Image: )\n\nFinally, we create a VariableWeightSpecies which holds the all of the macroparticles. Additionally, we must pass the value of particles_per_macro, which is used to calculate the charge and mass of the macroparticles.\n\nelectrons = ParticleInCell.electrons(positions, momentums, particles_per_macro);\n\nNow we address the 'cell' piece of particle-in-cell by creating a grid. Because Langmuir oscillations are a one-dimensional phenomena, we will choose to perform a 1D simulation.\n\nThe choice of grid resolution is determined by the scale of the smallest relevant dynamics begin simulated. For a Langmuir oscillation, the scale of the dynamics is set by k, and so the simulation could likely accomplished with as few as 4 or 8 cells. However, this is not a computationally demanding simulation, and so we arbitrarily choose to use 32 equally spaced (i.e. uniform) grid points. Additionally, we make the simulation domain periodic.\n\nnum_cells = 32\ndx = sim_length / num_cells\nperiodic = true\ngrid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (periodic,));\n\nAt this point, we must choose a timestep for the simulation. We would like to use a large timestep so that more of the systems dynamics can be observed with the same number of steps. However, we must resolve the fastest timescale of the dynamics that we are trying to simulate. In this case, we must resolve the plasma frequency. Additionally, we must choose a timestep that is short enough that particles do not cross more than one cell per timestep to prevent numerical instabilities from arising. For the oscillation amplitude that we have chosen, the particles do not move fast enough for the CFL condition to matter, and so we will choose our timestep based on the expected plasma frequency.\n\nepsilon_0 = 8.8e-12\nelec_charge = 1.6e-19\nelec_mass = 9e-31\nexpected_plasma_freq = sqrt(number_density * elec_charge^2 / elec_mass / epsilon_0)\nexpected_plasma_period = 2pi / expected_plasma_freq\n\n1.1051531770007306e-8\n\nIn order for the simulation to be accurate, there must be several timesteps per plasma period (or equivalently, several timesteps per inverse plasma frequency). For now, we will arbitrarily choose to have 100 timesteps per plasma period, and later, we will explore how changing the time step effects the accuracy of the simulation.\n\ndt = 0.01 / expected_plasma_freq\n\n1.7589059099337862e-11\n\nNow we need to set up the fields required for the electrostatic PIC simulation, as well as specify the exact steps that will occur during each step.. To do this, we will use a helper function to create the fields and steps.\n\nsim, fields = create_electrostatic_simulation(grid, [electrons], dt);\n\nThe variable sim holds the steps, and fields is a named tuple of the rho, phi, and electric fields (actually two electric fields, one at the edge of each grid cell, and one at the nodes). In this tutorial, we won't go over the details of the PIC method, but you can find more details in the theory section of the manual. However, we will need the nodal electric field later in the tutorial, so we assign that field to its own variable.\n\nEnode = fields[:Enode];\n\nNow we are ready to run the simulation. We will simulate the plasma for 1000 timesteps, and at each step, we will calculate the electric field energy,\n\nU_E = int E(x)^2 mathrmdx\n\nThis field energy will oscillate as the electrons move in and out of equilibrium, and so we can use it to observe the Langmuir oscillation.\n\nn_steps = 10000\n\nelectric_field_energy = Vector{Float64}(undef, n_steps)\n\nfor n = 1:n_steps\n    # Calculate the electric field energy\n    electric_field_energy[n] = 0\n    for I in eachindex(Enode)\n        electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2\n    end\n\n    step!(sim)\nend\n\nWe can now visualize the electric field energy to see the plasma oscillation.\n\nnormalized_times = collect(range(1, n_steps)) .* dt .* expected_plasma_freq\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Electric Field Energy\",\n    xlabel = \"Normalized Time\",\n    ylabel = \"Energy\",\n    limits = ((0, 100), nothing),\n)\nlines!(normalized_times, electric_field_energy)\nfig\n\n(Image: )\n\nNotice that the electric field energy is slowly growing over time, which is unphysical. We will discuss where this numerical instability comes from– and how it can be avoided–later. But for now, we can still use the electric-field-energy time series to calculate the plasma frequency. First, let's plot the Fourier transform of the electric field energy.\n\nusing FFTW\n\nfreqs = fftfreq(n_steps, 1 / dt) .* 2pi\nfreq_amps = abs.(fft(electric_field_energy))\n\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Electric Field Energy Spectrum\",\n    xlabel = \"Frequency\",\n    ylabel = \"Amplitude\",\n)\nlines!(ax, freqs, freq_amps)\nfig\n\n(Image: )\n\nIt is hard to see what is happening at the low frequencies, so let's zoom in on the positive low frequencies.\n\ncutoff_index = round(Int, n_steps * 0.005)\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Electric Field Energy Spectrum\",\n    xlabel = \"Frequency\",\n    ylabel = \"Amplitude\",\n)\nlines!(ax, freqs[1:cutoff_index], freq_amps[1:cutoff_index])\nfig\n\n(Image: )\n\nNext, we find the maximum frequency. We don't care about the spike at zero frequency (that is just a consequence of the electric field energy being a strictly positive quantity) so we will zero out all of the frequencies below 5 times 10^8 Hz. We then find the largest remaining amplitude, and it's corresponding frequency.\n\nfreq_amps .= ifelse.(freqs .< 5e8, 0, freq_amps)\nmax_index = findmax(freq_amps)[2]\nmax_freq = freqs[max_index]\n\n# Divide by 2 because the electric field energy goes through a maximum twice\n# per plasma oscillation, and take the absolute value because we don't care\n# about the phase of the oscillation.\nmeasured_plasma_freq = abs(max_freq / 2)\n\n5.5369290484077e8\n\nOne last plot, showing the zeroed out low frequencies, and the measured oscillation frequency:\n\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Electric Field Energy Spectrum\",\n    xlabel = \"Frequency\",\n    ylabel = \"Amplitude\",\n)\nlines!(ax, freqs[1:cutoff_index], freq_amps[1:cutoff_index])\nvlines!(ax, [measured_plasma_freq * 2])\nfig\n\n(Image: )\n\nFinally, we can compare this to the theoretically expected result:\n\nrelative_error = (measured_plasma_freq - expected_plasma_freq) / expected_plasma_freq\n\n-0.026106277387164183\n\nLess than a 5% error.","category":"section"},{"location":"examples/tutorial/langmuir_oscillation/#Scaling-of-frequency-error-with-wavenumber","page":"Tutorial","title":"Scaling of frequency error with wavenumber","text":"In the previous section, we seeded a plasma oscillation that spanned the entire simulation domain. That is, the wavenumber was\n\nk_textmin = frac2 pilambda = frac2 piL\n\nThis is the best possible case, because the oscillation spans as many grid cells as possible. However, as the wavenumber increases (and equivalently, the wavelength decreases), the finite grid effects will start to become more important, and they will result in an increased error in the measured plasma frequency.\n\nOur goal in this section will be to observe and quantify this finite grid error. We begin by defining a function that will run a PIC simulation at a specified wavenumber, and return the measured plasma frequency.\n\nfunction measure_plasma_frequency(number_density, wavenumber, normalized_timestep = 0.01)\n    sim_length = 1.0\n    num_cells = 32\n    dx = sim_length / num_cells\n\n    num_macroparticles = 10 * num_cells\n    particles_per_macro = number_density * sim_length / num_macroparticles\n\n    perturb_amplitude = 1e3\n    elec_mass = 9e-31\n    positions = collect(0:num_macroparticles-1) ./ num_macroparticles\n    momentums =\n        (particles_per_macro * elec_mass * perturb_amplitude) .*\n        sin.(positions .* wavenumber)\n\n    electrons = ParticleInCell.electrons(positions, momentums, particles_per_macro)\n\n    grid = UniformCartesianGrid((0.0,), (sim_length,), (num_cells,), (true,))\n\n    epsilon_0 = 8.8e-12\n    elec_charge = 1.6e-19\n    expected_plasma_freq = sqrt(number_density * elec_charge^2 / elec_mass / epsilon_0)\n    dt = normalized_timestep / expected_plasma_freq\n    sim, fields = create_electrostatic_simulation(grid, [electrons], dt)\n    Enode = fields[:Enode]\n\n    # We want to simulate the same length of physical time for each simulation,\n    # so we need to have more steps when the timestep is shorter.\n    n_steps = round(Int, 100 / normalized_timestep)\n    electric_field_energy = Vector{Float64}(undef, n_steps)\n\n    epsilon_0 = 8.8e-12\n    for n = 1:n_steps\n        # Calculate the electric field energy\n        electric_field_energy[n] = 0\n        for I in eachindex(Enode)\n            electric_field_energy[n] += (dx * epsilon_0 / 2) * (Enode.values[I])^2\n        end\n\n        step!(sim)\n    end\n\n    freqs = fftfreq(n_steps, 1 / dt) .* 2pi\n    freq_amps = abs.(fft(electric_field_energy))\n\n    freq_amps[1] = 0\n    max_index = findmax(freq_amps)[2]\n    max_freq = freqs[max_index]\n    plasma_freq = abs(max_freq / 2)\n\n    return plasma_freq\nend;\n\nLet's run several simulations with different timesteps, and compare the accuracy of each simulation.\n\nwavenumbers = 2 * pi .* [2, 4, 8, 16]\nplasma_freqs = measure_plasma_frequency.(1e14, wavenumbers, 0.001)\n\n4-element Vector{Float64}:\n 5.536929048407701e8\n 5.179707819478172e8\n 3.9294335182248205e8\n 1.7861061446476456e7\n\nLet's plot the wavenumber of the oscillation verses the relative error between the observed and predicted plasma frequencies. We expect that the error will be some power law relation to the wavenumber, and so we will use a log-log plot.\n\ndx = 1 / 32\nnormalized_wavenumbers = wavenumbers .* dx\nrelative_errors = abs.(plasma_freqs ./ expected_plasma_freq .- 1)\n\nfig = Figure(size = (1000, 400))\nax = Axis(\n    fig[1, 1],\n    title = \"Frequency error\",\n    xlabel = L\"k \\Delta x\",\n    ylabel = L\"\\left|\\frac{\\omega}{\\omega_p} - 1\\right|\",\n    xscale = log10,\n    yscale = log10,\n)\nscatter!(ax, normalized_wavenumbers, relative_errors)\nfig\n\n(Image: )\n\nIndeed, the error does appear to have a power law relation with the normalized wavenumber. Let's fit the data to determine the index of the power law. We will use the LsqFit package, which provides utilities for fitting data. We have observed that the data is linear when plotted on a log-log plot, and so we will fit the log-transformed data using a linear model.\n\nusing LsqFit\n\nmodel(x, p) = p[1] .+ x .* p[2]\nfit = curve_fit(model, log10.(normalized_wavenumbers), log10.(relative_errors), [0.0, 2.0])\nparams = coef(fit)\n\n2-element Vector{Float64}:\n -0.8690885032869285\n  1.743625642496926\n\nNotice that the second parameter, which corresponds to the exponent in the power law, is about two. This makes sense, because the PIC algorithm we are using has second order accuracy in k Delta x. As a final sanity check, let's plot the fit.\n\nlines!(\n    ax,\n    normalized_wavenumbers,\n    (10^params[1]) .* normalized_wavenumbers .^ params[2],\n    color = :red,\n)\nfig\n\n(Image: )\n\nThere is one last thing we can do with this error model: we can us it to correct out simulation results! Our model gives us the relation\n\nleftfracomegaomega_p - 1right = C (k Delta x)^p\n\nWe can solve for omega_p, to obtain\n\nomega_p = fracomega1 pm C (k Delta x)^p\n\nLet's find the error in the corrected plasma frequencies.\n\ncorrected_plasma_freqs =\n    plasma_freqs ./ (1 .- (10^params[1]) .* normalized_wavenumbers .^ params[2])\ncorrected_relative_errors =\n    (corrected_plasma_freqs .- expected_plasma_freq) ./ expected_plasma_freq\n\n4-element Vector{Float64}:\n  0.0003955396156326958\n -0.00024698896102469636\n -0.01674606541861653\n  5.092479974228979\n\nOf course, this example is somewhat unrealistic: if we already know what the plasma frequency should be, why are we running simulations to measure it?!?! However, this general technique remains valid, even when we don't know what the correct answer is a priori. This is why it is so important to conduct scaling studies to gain confidence that your simulation is actually resolving the physics that you think it is.","category":"section"},{"location":"examples/tutorial/langmuir_oscillation/#Wrap-up","page":"Tutorial","title":"Wrap up","text":"In this tutorial, you have learned how to simulate an electrostatic Langmuir oscillation using ParticleInCell. Additionally, you have verified error scaling of the algorithm in k Delta x, and used this information to correct the originally measured plasma frequency.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/electrostatic/beam_plasma/#Beam-plasma-instability","page":"Beam-plasma instability","title":"Beam-plasma instability","text":"(Image: Source code) (Image: notebook)\n\nComing soon...\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"#ParticleInCell.jl","page":"Introduction","title":"ParticleInCell.jl","text":"","category":"section"},{"location":"#Documentation-sections","page":"Introduction","title":"Documentation sections","text":"To get started, look at the Tutorial, which includes step-by-step instructions for running your first simulation using ParticleInCell. After that, you may want to browse the Example Gallery, to see other problems that this package can be used to solve. The Plasma Simulation Theory section contains information about the art of computational plasma physics, and the numerical constraints that require the specialized tools developed here. Finally, the Manual contains detailed information about the entire public interface of the package.","category":"section"},{"location":"#ParticleInCell","page":"Introduction","title":"ParticleInCell","text":"(Image: ParticleInCell.jl Logo)\n\n(Image: Latest Documentation) (Image: CI Status)\n\nParticleInCell.jl is a Julia package for kinetic plasma physics simulation. Specifically, it focuses on the simulation of kinetic (non-thermal) plasmas using particle-in-cell (PIC) algorithms. Currently, this package is in in a pre-1.0.0 state, and thus breaking changes should be expected. However, this also means that I am willing to entertain radical suggestions to improve the functionality of the package. If you are interested in using ParticleInCell for your plasma research, and you find that it does not meet you needs, please reach out on either GitHub, or over email, so that we can discuss how the package can be modified to suite your needs.\n\nGetting Started\n\nParticleInCell is registered in the Julia package registry. Thus, to install this package, you can simply Pkg.add:\n\nusing Pkg\nPkg.add(\"ParticleInCell\")\n\nDocumentation\n\nYou can view the latest documentation here.\n\nGoals\n\nFast: aim to have core time of less than 1 microsecond per particle per step without collisions.\nFlexible: it should be possible to implement essentially any kinetic plasma simulation in ParticleInCell.jl. For common types of simulations, this might mean just piecing together components that are already included. More esoteric problems might require writing custom types that implement the desired algorithms. The advantage of writing this package in Julia is that these custom types will be just as performant as native components that are included in the package.\nScalable: the eventual goal is to enable scaling across an essentially unlimited number of cores using Julia's native multithreading for parallelization on a single node, and MPI.jl for communication across nodes. The goal is to support two different modes of parallelization:\nEach core is responsible for a single rectangular subdomain. The domain assigned to an entire node is also rectangular, which imposes constraints on how the node domain can be subdivided into subdomains for each core. Load balancing is achieved by varying the relative sizes of the domains such that each core has a similar amount of work per step.\nThe simulation domain is subdivided into subdomains called 'patches', and every node is assigned a list of patches that it is responsible for updating. The cores on each node work collaboratively on the list, each choosing one patch to work on, and then selecting another when they are finished. Load balancing is achieved by swapping patches between nodes to balance the workload while also seeking to minimize communication time by keeping the surface area of each node's responsibilities minimized. In order for this scheme to effectively load balance, it must be the case that the total number of patches is larger (ideally much larger) that the total number of cores.\n\n\n\n\n\n","category":"module"}]
}
